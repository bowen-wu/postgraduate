<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ ¸å¿ƒè¯æ±‡æ™ºèƒ½å¤ä¹  | VocabMaster V5</title>
    <style>
        :root {
            --primary: #4f46e5;
            --primary-hover: #4338ca;
            --primary-light: #e0e7ff;
            --secondary: #64748b;
            --success: #10b981;
            --success-bg: #d1fae5;
            --danger: #ef4444;
            --danger-bg: #fee2e2;
            --background: #f1f5f9;
            --card-bg: #ffffff;
            --text-main: #1e293b;
            --text-sub: #475569;
            --border-color: #e2e8f0;
            --radius-lg: 16px;
            --radius-md: 8px;
            --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background);
            color: var(--text-main);
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            position: fixed;
            width: 100%;
        }
        /* --- Header --- */
        header {
            background: var(--card-bg);
            padding: 0.75rem 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            z-index: 20;
            flex-shrink: 0;
        }
        .brand { font-weight: 800; font-size: 1.2rem; color: var(--primary); display: flex; align-items: center; gap: 0.5rem; }
        .current-file-display {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-main);
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .header-controls { display: flex; gap: 0.75rem; align-items: center; }
        button {
            border: none; outline: none;
            padding: 0.5rem 1rem;
            border-radius: var(--radius-md);
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex; align-items: center; gap: 0.4rem;
            background: #f1f5f9; color: var(--text-sub);
            white-space: nowrap;
        }
        button:hover { background: #e2e8f0; }
        button:active { transform: scale(0.96); }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); }
        .btn-success { background: var(--success); color: white; }
        .btn-danger { background: var(--danger); color: white; }
        .btn-ghost { background: transparent; color: var(--secondary); }
        .btn-ghost:hover { background: rgba(0, 0, 0, 0.05); }
        .toggle-switch {
            display: flex; background: #e2e8f0; padding: 3px; border-radius: 20px; position: relative;
        }
        .toggle-switch button {
            background: transparent; padding: 0.4rem 0.8rem; font-size: 0.8rem; border-radius: 18px; z-index: 1; color: var(--secondary);
        }
        .toggle-switch button.active { background: white; color: var(--primary); box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
        /* --- Layout --- */
        main { flex: 1; position: relative; overflow: hidden; display: flex; min-height: 0; }
        @media (max-width: 600px) {
            .header-controls { gap: 0.5rem; }

            .brand {
                font-size: 0.9rem;
                flex: 1;
                margin-right: 0.2rem;
            }

            .toggle-switch {
                max-width: 200px;
            }

            button {
                padding: 0.4rem 0.75rem;
                font-size: 0.85rem;
            }
        }
        /* Sidebar */
        aside {
            width: 320px;
            background: var(--card-bg);
            border-right: 1px solid var(--border-color);
            position: absolute; top: 0; bottom: 0; left: 0;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 30;
            display: flex; flex-direction: column;
        }
        aside.open { transform: translateX(0) !important; }
        #filePanel.open { z-index: 66; }
        /* File panel on top when open */
        #statsPanel.open { z-index: 30; }
        .aside-header { padding: 1rem; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: bold; }
        .stats-list { flex: 1; overflow-y: auto; padding: 1rem; }
        .stat-row { display: flex; justify-content: space-between; padding: 0.5rem; border-bottom: 1px solid #f1f5f9; font-size: 0.9rem; cursor: pointer; }
        .stat-row:hover { background: #f8fafc; }
        .stat-row.active { background: var(--primary-light); font-weight: bold; }
        .stat-word { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        .tag-pill { font-size: 0.7rem; padding: 1px 4px; border-radius: 4px; margin-right: 4px; background: #e2e8f0; }
        /* File Selection Styles */
        .file-item, .folder-item {
            display: flex; align-items: center; gap: 0.5rem;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #f1f5f9;
            cursor: pointer;
            transition: background 0.2s;
        }
        .file-item:hover, .folder-item:hover { background: #f8fafc; }
        .file-item.active, .folder-item.active { background: var(--primary-light); font-weight: bold; }
        .file-item-icon, .folder-item-icon { font-size: 1.2rem; flex-shrink: 0; }
        .file-item-name, .folder-item-name { flex: 1; font-size: 0.9rem; }
        .folder-item-name { font-weight: 600; }
        .breadcrumb {
            padding: 0.5rem 1rem;
            background: #f8fafc;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.85rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }
        .breadcrumb-item {
            color: var(--secondary);
            cursor: pointer;
        }
        .breadcrumb-item:hover { color: var(--primary); }
        .breadcrumb-separator { color: var(--secondary); }
        .current-file-info {
            padding: 0.75rem 1rem;
            background: var(--primary-light);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        /* Workspace */
        .workspace {
            flex: 1; padding: 2rem; display: flex; justify-content: center; align-items: center; overflow-y: auto; position: relative;
        }
        /* File Title Bar (shows current file name above card) */
        .file-title-bar {
            width: 100%; max-width: 800px;
            background: var(--card-bg);
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
            border-radius: var(--radius-md);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            text-align: center;
            display: none; /* Hidden on desktop by default */
        }
        .file-title-text {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-main);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        /* Card */
        .card {
            background: var(--card-bg);
            width: 100%; max-width: 800px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow);
            display: flex; flex-direction: column;
            min-height: 500px; max-height: 90vh;
            position: relative;
            overflow: hidden;
        }
        .card-header {
            padding: 1.5rem 2rem;
            background: linear-gradient(to right, #ffffff, #f8fafc);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        /* Hide header for phrase cards */
        .card.is-phrase .card-header {
            display: none;
        }
        .word-title-group { display: flex; align-items: baseline; gap: 0.75rem; flex-wrap: wrap; }
        .main-word { font-size: 2.5rem; font-weight: 800; color: var(--text-main); line-height: 1.1; display: flex; align-items: center; gap: 0.5rem; }
        .main-word button { opacity: 0.6; transition: opacity 0.2s; }
        .main-word button:hover { opacity: 1; }
        .pronunciation { font-family: "Lucida Console", Monaco, monospace; color: var(--secondary); font-size: 1.2rem; background: #f1f5f9; padding: 2px 6px; border-radius: 4px; display: none !important; }
        .badges { display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap; }
        .badge { font-size: 0.75rem; padding: 4px 8px; border-radius: 6px; font-weight: 600; text-transform: uppercase; }
        .badge-word { background: #d1fae5; color: #10b981; }
        .badge-rel { background: #f3e8ff; color: #9333ea; border: 2px solid #d8b4fe; }
        .badge-syn { background: #f3e8ff; color: #9333ea; }
        .badge-sent { background: #dbeafe; color: #2563eb; }
        .badge-err { background: var(--danger-bg); color: var(--danger); }
        /* Phrase title in card body */
        .phrase-title {
            font-size: 1.6rem;
            font-weight: 700;
            color: #7c3aed;
            line-height: 1.4;
            margin-bottom: 1rem;
            padding-left: 1rem;
            border-left: 4px solid #a855f7;
        }
        /* Phrase header wrapper - contains title and badge */
        .phrase-header-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }
        .phrase-header-wrapper .phrase-title {
            margin-bottom: 0;
            flex: 1;
        }
        .phrase-header-wrapper .badges-container {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
        }
        .card-body {
            flex: 1; overflow-y: auto; padding: 2rem;
        }
        .item-list { list-style: none; display: flex; flex-direction: column; gap: 1.5rem; }
        /* Hide definition items in recall mode until user clicks "è®°å¾—" */
        body.mode-recall .item-list {
            display: none;
        }
        body.mode-recall .item-list.revealed {
            display: flex;
        }
        .item { position: relative; }
        .item-tag {
            font-size: 0.75rem; font-weight: 700; text-transform: uppercase; color: var(--secondary);
            margin-bottom: 0.5rem; display: block; letter-spacing: 0.05em;
        }
        .tag-def::before { content: "DEFINITION"; color: var(--primary); }
        .en-text { font-size: 1.25rem; color: var(--text-main); line-height: 1.6; font-weight: 500; margin-bottom: 0.5rem; }
        .cn-text { font-size: 1rem; color: var(--text-sub); line-height: 1.5; transition: all 0.3s; padding-left: 1rem; border-left: 3px solid var(--border-color); cursor: pointer; }
        /* Synonyms Styles */
        .synonyms-section {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid #e2e8f0;
        }
        .synonyms-label {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--secondary);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        .synonyms-label::before {
            content: "ğŸ”„";
            font-size: 1rem;
        }
        .synonym-item {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            margin-right: 1rem;
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.75rem;
            background: #f3e8ff;
            border-radius: 8px;
            font-size: 0.9rem;
        }
        .synonym-word {
            font-weight: 600;
            color: #9333ea;
        }
        .synonym-def {
            color: #6b7280;
            font-size: 0.85rem;
        }
        .synonym-play-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.2rem;
            opacity: 0.6;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
        }
        .synonym-play-btn:hover {
            opacity: 1;
        }
        /* Synonyms in recall mode */
        body.mode-recall .synonyms-section {
            display: none;
        }
        body.mode-recall .synonyms-section.revealed {
            display: block;
        }
        /* Sentence Card Styles */
        .card.is-sentence .card-header {
            display: none;
        }
        .sentence-label {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--secondary);
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .sentence-label::before {
            content: "ğŸ’¬";
            font-size: 1rem;
        }
        .sentence-content { font-size: 1.35rem; line-height: 1.8; color: var(--text-main); font-weight: 400; margin-bottom: 1rem; }
        .sentence-content .highlight-word { background: linear-gradient(120deg, var(--primary-light) 0%, transparent 100%); padding: 2px 4px; border-radius: 4px; font-weight: 600; }
        .card.is-sentence .card-body { padding: 2rem; }
        .card.is-sentence .card-footer { border-top: 1px solid var(--border-color); background: var(--card-bg); }
        .sentence-cn {
            font-size: 1.05rem;
            color: var(--text-sub);
            line-height: 1.6;
            padding: 1rem;
            background: #f8fafc;
            border-left: 3px solid var(--primary);
            border-radius: 0 8px 8px 0;
            margin-top: 1rem;
        }
        /* Sentence Chinese in recall mode */
        body.mode-recall .sentence-cn {
            filter: blur(6px);
            opacity: 0.4;
            user-select: none;
            cursor: pointer;
        }
        body.mode-recall .sentence-cn.revealed {
            filter: none;
            opacity: 1;
            cursor: default;
        }
        /* Sentence English content in recall mode */
        body.mode-recall .sentence-content.blur-target {
            filter: blur(4px);
            opacity: 0.7;
        }
        body.mode-recall .sentence-content.blur-target.revealed {
            filter: none;
            opacity: 1;
        }
        /* Recall Mode Styles */
        body.mode-recall .cn-text {
            filter: blur(10px); opacity: 0; user-select: none;
        }
        body.mode-recall .cn-text:hover { filter: blur(6px); opacity: 0; }
        body.mode-recall .cn-text.revealed { filter: none; opacity: 1; transform: translateX(0); border-left-color: var(--primary); cursor: default; }
        body.mode-recall .en-text { filter: blur(8px); opacity: 0; }
        body.mode-recall .en-text.revealed { filter: none; opacity: 1; }
        .card-footer {
            padding: 1.25rem 2rem;
            border-top: 1px solid var(--border-color);
            display: flex; justify-content: space-between; align-items: center;
            background: #fafafa;
            flex-shrink: 0;
            min-height: 70px;
        }
        .progress-indicator { font-size: 0.9rem; color: var(--secondary); font-variant-numeric: tabular-nums; }
        .action-area { display: flex; gap: 0.75rem; flex-wrap: wrap; justify-content: flex-end; }
        .toast {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%) translateY(-20px);
            background: #1e293b; color: white; padding: 0.75rem 1.5rem; border-radius: 50px;
            font-size: 0.9rem; font-weight: 500; opacity: 0; transition: 0.3s; pointer-events: none;
            z-index: 100; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
        .loader {
            position: absolute; inset: 0; background: var(--background);
            display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 1rem; z-index: 50;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #e2e8f0; border-top-color: var(--primary); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .hidden { display: none !important; }
        /* Confirmation Dialog */
        .dialog-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        .dialog-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }
        .dialog {
            background: var(--card-bg);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow);
            max-width: 400px;
            width: 90%;
            padding: 2rem;
            transform: scale(0.95);
            transition: transform 0.2s;
        }
        .dialog-overlay.show .dialog {
            transform: scale(1);
        }
        .dialog-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-main);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .dialog-message {
            font-size: 1rem;
            color: var(--text-sub);
            line-height: 1.6;
            margin-bottom: 1.5rem;
        }
        .dialog-message .highlight {
            color: var(--primary);
            font-weight: 600;
        }
        .dialog-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }
        @media (max-width: 600px) {
            /* Show file title bar on mobile */
            .file-title-bar { display: block; }

            .brand {
                flex-shrink: 1;
                min-width: 0;
            }

            /* Ensure header-controls doesn't get squeezed */
            .header-controls {
                flex-shrink: 0;
                gap: 0.5rem;
            }

            /* Make toggle-switch more compact on mobile */
            .toggle-switch {
                max-width: 140px;
            }

            .toggle-switch button {
                padding: 0.4rem 0.6rem;
                font-size: 0.75rem;
            }

            /* Fix workspace layout on mobile - stack vertically */
            .workspace {
                flex-direction: column;
                padding: 1rem;
            }

            .file-title-bar {
                flex-shrink: 0;
                margin-bottom: 0.5rem;
            }

            .card { height: 100%; max-height: 100vh; border-radius: 0; }

            .card-header { padding: 1rem; }

            .card-body { padding: 1rem; }

            .card-footer { padding: 1rem; flex-direction: column; align-items: stretch; gap: 1rem; }

            .action-area { justify-content: space-between; }

            .main-word { font-size: 1.8rem; }

            /* Phrase card mobile adjustments */
            .phrase-title {
                font-size: 1.3rem;
                padding-left: 0.75rem;
                margin-bottom: 0.75rem;
            }

            .card.is-phrase::before {
                width: 4px;
            }

            .card.is-phrase {
                border-width: 1px;
            }

            aside { width: 85%; }
        }
    </style>
</head>
<body>
<header>
    <div class="brand">
        <button class="btn-ghost" onclick="app.toggleFiles()" title="é€‰æ‹©æ–‡ä»¶">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 3h18v18H3z"></path>
                <path d="M9 3v18"></path>
                <path d="M3 9h18"></path>
            </svg>
        </button>
        <span id="currentFileDisplay" class="current-file-display"></span>
    </div>
    <div class="header-controls">
        <div class="toggle-switch">
            <button id="btnModeInput" class="active" onclick="app.setMode('input')">æµè§ˆ</button>
            <button id="btnModeRecall" onclick="app.setMode('recall')">é®æŒ¡</button>
        </div>

        <button class="btn-ghost" onclick="app.toggleStats()">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="20" x2="18" y2="10"></line>
                <line x1="12" y1="20" x2="12" y2="4"></line>
                <line x1="6" y1="20" x2="6" y2="14"></line>
            </svg>
        </button>
    </div>
</header>
<aside id="filePanel">
    <div class="aside-header">
        <span>é€‰æ‹©æ–‡ä»¶</span>
        <div style="display: flex; gap: 0.5rem;">
            <button class="btn-ghost" onclick="app.refreshFileList()" title="åˆ·æ–°åˆ—è¡¨"
                    style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">
                ğŸ”„
            </button>
            <button class="btn-ghost" onclick="app.toggleFiles()">âœ•</button>
        </div>
    </div>
    <div class="stats-list" id="fileListContainer">
        <div style="padding: 1rem; text-align: center; color: var(--secondary);">
            <div class="spinner" style="margin: 0 auto 1rem;"></div>
            åŠ è½½ä¸­...
        </div>
    </div>
</aside>

<aside id="statsPanel">
    <div class="aside-header">
        <span>å­¦ä¹ åˆ—è¡¨</span>
        <button class="btn-ghost" onclick="app.toggleStats()">âœ•</button>
    </div>
    <div class="stats-list" id="wordListContainer"></div>
    <div style="padding: 1rem; border-top: 1px solid #f1f5f9;">
        <button class="btn-danger" style="width: 100%; justify-content: center;" onclick="app.resetData()">é‡ç½®è¿›åº¦
        </button>
    </div>
</aside>
<main>
    <div id="loader" class="loader">
        <div class="spinner"></div>
        <p>æ­£åœ¨æ·±åº¦è§£æå¥å­ä¸ç”Ÿè¯...</p>
    </div>
    <div class="workspace">
        <article class="card hidden" id="cardContainer">
            <header class="card-header">
                <div class="word-title-group">
                    <span class="main-word" id="displayWord">Loading...</span>
                    <span class="pronunciation" id="displayPronunciation"></span>
                </div>
                <div class="badges" id="displayBadges"></div>
            </header>
            <div class="card-body">
                <ul class="item-list" id="itemList"></ul>
            </div>
            <footer class="card-footer">
                <button class="btn-ghost" onclick="app.prevCard()" id="btnPrev">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>
                    ä¸Šä¸€ä¸ª
                </button>
                <span class="progress-indicator" id="progressText">0 / 0</span>
                <div class="action-area" id="actionArea"></div>
            </footer>
        </article>
    </div>
</main>
<div id="toast" class="toast">Message</div>

<!-- Confirmation Dialog -->
<div id="confirmDialog" class="dialog-overlay">
    <div class="dialog">
        <div class="dialog-title">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--primary)" stroke-width="2">
                <path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
            </svg>
            <span>åˆ‡æ¢æ–‡ä»¶</span>
        </div>
        <div class="dialog-message" id="dialogMessage"></div>
        <div class="dialog-actions">
            <button class="btn-ghost" onclick="app.confirmDialog.cancel()">å–æ¶ˆ</button>
            <button class="btn-primary" id="dialogConfirmBtn">ç¡®å®š</button>
        </div>
    </div>
</div>
<script>
  /**
   * CONFIGURATION & STATE
   */
  const CONFIG = {
    baseApiUrl: 'https://api.github.com/repos/bowen-wu/postgraduate/contents/english/word',
    baseRawUrl: 'https://raw.githubusercontent.com/bowen-wu/postgraduate/refs/heads/master/english/word',
    storageKey: 'vocab_master_v8_data',
    cacheKey: 'vocab_master_v8_cache',
    cacheDuration: 24 * 60 * 60 * 1000,  // 24 hours in ms
    version: 5,  // V2: Refactored card types (word|phrase|sentence)
    // Audio sources priority (local â†’ cambridge â†’ TTS)
    localAudioBaseUrl: 'https://bowen-wu.github.io/postgraduate/english/audio',
    corsProxy: 'https://corsproxy.io/?'
    // Alternative proxies (uncomment if needed):
    // corsProxy: 'https://api.allorigins.win/raw?url=',
    // corsProxy: 'https://cors-anywhere.herokuapp.com/',
  };
  const STATE = {
    cards: [],
    currentIndex: 0,
    mode: 'input',
    stats: {},
    currentPath: null,  // e.g., "core/Unit10-1.md"
    currentFile: null   // Current file info from GitHub API
  };

  /**
   * GITHUB API HELPER
   */
  class GitHubApi {
    static getCacheKey(path) {
      return `${CONFIG.cacheKey}_${path || 'root'}`;
    }

    static getCachedData(path) {
      try {
        const cacheKey = this.getCacheKey(path);
        const cached = localStorage.getItem(cacheKey);
        if (!cached) return null;

        const parsed = JSON.parse(cached);
        const now = Date.now();

        // Check if cache is still valid
        if (now - parsed.timestamp < CONFIG.cacheDuration) {
          console.log(`âœ… Using cached data for: ${path || 'root'}`);
          return parsed.data;  // Return the wrapped data
        } else {
          // Cache expired
          localStorage.removeItem(cacheKey);
          return null;
        }
      } catch (e) {
        console.warn('Cache read error:', e);
        return null;
      }
    }

    static setCachedData(path, data) {
      try {
        const cacheKey = this.getCacheKey(path);
        // Don't use spread operator on arrays!
        const cacheData = {
          data: data,  // Wrap data properly
          timestamp: Date.now()
        };
        localStorage.setItem(cacheKey, JSON.stringify(cacheData));
        console.log(`ğŸ’¾ Cached data for: ${path || 'root'}`);
      } catch (e) {
        console.warn('Cache write error:', e);
      }
    }

    static clearCache() {
      const keys = Object.keys(localStorage);
      keys.forEach(key => {
        if (key.startsWith(CONFIG.cacheKey)) {
          localStorage.removeItem(key);
        }
      });
      console.log('ğŸ—‘ï¸ All cache cleared');
    }

    static async fetchContents(path = '', forceRefresh = false) {
      const url = path ? `${CONFIG.baseApiUrl}/${path}` : CONFIG.baseApiUrl;

      // Try cache first
      if (!forceRefresh) {
        const cached = this.getCachedData(path);
        if (cached) return cached;
      }

      // Fetch from API
      const res = await fetch(url);

      // Handle rate limiting
      if (res.status === 403) {
        const resetTime = res.headers.get('X-RateLimit-Reset');
        const resetDate = resetTime ? new Date(parseInt(resetTime) * 1000) : null;
        const timeRemaining = resetDate ? Math.ceil((resetDate - Date.now()) / 60000) : 60;

        throw new Error(
          `GitHub API é€Ÿç‡é™åˆ¶å·²è¾¾åˆ°ã€‚è¯·ç­‰å¾… ${timeRemaining} åˆ†é’Ÿåé‡è¯•ï¼Œæˆ–ç‚¹å‡»"åˆ·æ–°åˆ—è¡¨"æŒ‰é’®ã€‚`
        );
      }

      if (!res.ok) throw new Error(`GitHub API Error: ${res.status} ${res.statusText}`);

      const data = await res.json();
      console.log('GitHub API Response:', data);

      // GitHub API returns array for directories, single object for files
      // Ensure we always work with an array
      const contents = Array.isArray(data) ? data : [data];

      // Cache the result
      this.setCachedData(path, contents);

      return contents;
    }

    static async fetchFileContent(path) {
      const url = `${CONFIG.baseRawUrl}/${path}`;
      console.log('ğŸ“¥ Fetching file content from URL:', url);
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Fetch Error: ${res.status}`);
      return await res.text();
    }

    static filterMdFiles(items) {
      if (!Array.isArray(items)) {
        console.error('filterMdFiles - items is not an array:', items);
        return [];
      }
      return items.filter(item =>
        item.type === 'file' &&
        item.name.endsWith('.md') &&
        item.name !== 'template.md' &&
        item.name !== 'basic.md'
      );
    }

    static filterFolders(items) {
      if (!Array.isArray(items)) {
        console.error('filterFolders - items is not an array:', items);
        return [];
      }
      return items.filter(item => item.type === 'dir');
    }

    static async fetchFolderContents(path, forceRefresh = false) {
      const contents = await this.fetchContents(path, forceRefresh);
      return {
        folders: this.filterFolders(contents),
        files: this.filterMdFiles(contents)
      };
    }
  }

  /**
   * REFACTORED MARKDOWN PARSER (V6 - Simplified Rules)
   *
   * === PARSE RULES (ç”¨æˆ·è§„åˆ™) ===
   *
   * è§„åˆ™1: ä»ç¬¬ä¸€ä¸ª ## å¼€å§‹è§£æ
   *   - å¿½ç•¥ç¬¬ä¸€ä¸ª ## ä¹‹å‰çš„æ‰€æœ‰å†…å®¹
   *
   * è§„åˆ™2: æ‰€æœ‰çš„ - éƒ½æ˜¯ä¸€ä¸ª Cardï¼Œå¦‚æœæ˜¯è¯æ€§åˆ™è·Ÿçˆ¶çº§
   *   - çº¯è¯æ€§è¡Œï¼ˆå¦‚ "n. ä¸­æ–‡"ï¼‰æ·»åŠ åˆ°çˆ¶å¡ç‰‡çš„ items
   *
   * è§„åˆ™3: åªè¦æœ‰è¯æ€§ï¼Œä¸€å®šæ˜¯å•è¯
   *   - æ£€æµ‹åˆ° pos. (adj., n., v., adv. ç­‰) â†’ word ç±»å‹
   *   - ä½¿ç”¨ hasPosMarker() æ£€æµ‹: /\s+(?!sb\.|sth\.)([a-z]+\.)/
   *
   * è§„åˆ™4: å¦‚æœæ˜¯ "- è¯ç»„" æˆ– "## è¯ç»„" çš„å­çº§ï¼Œé‚£ä¹ˆä¸€å®šæ˜¯è¯ç»„
   *   - æ ‡è®° "- è¯ç»„" å’Œ "## è¯ç»„" æœ¬èº«å¿½ç•¥ï¼ˆä¸åˆ›å»ºå¡ç‰‡ï¼‰
   *   - å­çº§å¡ç‰‡ç±»å‹ä¸º phrase
   *
   * è§„åˆ™5: å¥å­è§£æè§„åˆ™
   *   a) å…ˆåˆ é™¤ **xx** æ ‡è®°ä¸­çš„ ** ç¬¦å·
   *   b) *word(pos. def)* åŒ…è£¹çš„ï¼š
   *      - å¦‚æœæ‹¬å·å†…æœ‰è¯æ€§ â†’ æå–ä¸ºå•è¯å¡ç‰‡
   *      - å…¶ä»–æƒ…å†µ â†’ å¿½ç•¥
   *   c) <ins>phrase</ins> åŒ…è£¹çš„ â†’ æå–ä¸ºè¯ç»„å¡ç‰‡
   *   d) å¥å­çš„å­çº§ï¼ˆç¼©è¿›ï¼‰ï¼š
   *      - æœ‰è¯æ€§çš„ â†’ å•è¯å¡ç‰‡
   *      - å…¶ä½™ â†’ è¯ç»„å¡ç‰‡
   *
   * è§„åˆ™6: == æ ‡è®°çš„æ˜¯åŒä¹‰è¯
   *   - == word æˆ– === word â†’ æ·»åŠ åˆ°çˆ¶å¡ç‰‡çš„ synonyms
   *
   * === TYPE DETERMINATION LOGIC ===
   *
   * åˆ¤æ–­é¡ºåº (determineCardType):
   *   1. inPhraseList || inPhraseHeader â†’ phrase
   *   2. hasPosMarker(content) â†’ word
   *   3. hasIpaMarker(content) â†’ word
   *   4. firstChildHasPos(content, indentLevel) â†’ word
   *   5. å…¶ä»– â†’ sentence
   */
  class MarkdownParser {
 constructor(text) {
      this.lines = text.split('\n');
      this.cards = [];
      this.inPhraseList = false;  // Track if we're under "- è¯ç»„" marker
      this.inPhraseHeader = false;  // Track if we're under "## è¯ç»„" header
      this.parentCard = null;  // Current parent card for nested items
      this.parentLevel = -1;  // Indent level of parent card
      this.cardCounter = 0;  // For generating unique IDs
      this.pendingSynonyms = [];  // Store synonyms for current sentence
      this.debug = false;  // Set to true for debugging
    }

    /**
     * Main parse method - implements the new rule-based parsing logic
     */
    parse() {
      try {
        // Rule: Start from the first ##, ignore everything before
        let startIndex = 0;
        for (let i = 0; i < this.lines.length; i++) {
          if (this.lines[i].trim().startsWith('##')) {
            startIndex = i;
            break;
          }
        }

        let i = startIndex;
        while (i < this.lines.length) {
          const line = this.lines[i];
          const trimmed = line.trim();
          if (!trimmed) {
            i++;
            continue;
          }

          // Get indent level
          const indentMatch = line.match(/^(\s*)-/);
          const indentLevel = indentMatch ? indentMatch[1].length : 0;
          const content = trimmed.substring(1).trim();

          // Handle headers (## word)
          if (trimmed.startsWith('##')) {
            const headerWord = trimmed.substring(2).trim();
            if (this.isValidWordHeader(headerWord)) {
              // Check if this is a phrase header (è§„åˆ™4: ## è¯ç»„)
              this.inPhraseHeader = headerWord.includes('è¯ç»„');

              const card = this.createCard(headerWord, 'word');
              this.cards.push(card);
              this.parentCard = card;
              this.parentLevel = 0;
            }
            i++;
            continue;
          }

          // Handle list items (- ...)
          if (trimmed.startsWith('-')) {
            // Check if exiting phrase list (level-0 item after phrase marker)
            if (indentLevel === 0 && this.inPhraseList) {
              this.inPhraseList = false;
            }

            // Check for "- è¯ç»„" marker
            if (content === 'è¯ç»„') {
              this.inPhraseList = true;
              i++;
              continue;
            }

            // Process this list item
            this.processListItem(line, indentLevel, content, i);
          }

          i++;
        }


        return this.cards;
      } catch (error) {
        console.error('è§£æè¿‡ç¨‹å‡ºé”™:', error);
        throw new Error(`è§£æå¤±è´¥: ${error.message}`);
      }
    }

    /**
     * Process a single list item
     */
    processListItem(line, indentLevel, content, lineIndex) {
      if (this.debug) {
        console.log(`\n[DEBUG] Line ${lineIndex}: "${content}" (indent: ${indentLevel})`);
        console.log(`[DEBUG] parentCard: ${this.parentCard ? this.parentCard.word : 'null'}`);
      }

      // Rule 1: Check if it's a synonym marker (==)
      if (this.isSynonymMarker(content)) {
        if (this.debug) console.log(`[DEBUG] â†’ Synonym marker`);
        this.addSynonymToParent(content);
        return;
      }

      // Rule 2: Check if it's a pure POS line (belongs to parent)
      if (this.isPurePosLine(content)) {
        if (this.debug) console.log(`[DEBUG] â†’ Pure POS line, adding to parent`);
        this.addPosToParent(content);
        return;
      }

      // Rule 3: Check if it's a pure IPA line (belongs to parent)
      if (this.isPureIpaLine(content)) {
        if (this.debug) console.log(`[DEBUG] â†’ Pure IPA line, adding to parent`);
        this.addIpaToParent(content);
        return;
      }

      // Rule 4: Check for "è¯ç»„" marker (at any level)
      if (content === 'è¯ç»„') {
        if (this.debug) console.log(`[DEBUG] â†’ Phrase list marker`);
        this.inPhraseList = true;
        return;
      }

      // Rule 5: Exit phrase list mode on level-0 items
      if (indentLevel === 0 && this.inPhraseList) {
        if (this.debug) console.log(`[DEBUG] â†’ Exiting phrase list mode`);
        this.inPhraseList = false;
      }

      // Rule 6: Check if we're in phrase list (and indented)
      if (this.inPhraseList && indentLevel > 0) {
        if (this.debug) console.log(`[DEBUG] â†’ Creating phrase card (in phrase list)`);
        this.createPhraseCard(content);
        return;
      }

      // Rule 7: Determine card type
      const cardType = this.determineCardType(content, indentLevel);
      if (this.debug) console.log(`[DEBUG] â†’ Card type: ${cardType}`);

      // Create the card
      if (cardType === 'sentence') {
        this.processSentence(content, indentLevel, lineIndex);
      } else if (cardType === 'word') {
        const card = this.createWordCard(content, indentLevel);
        this.cards.push(card);
        if (this.debug) console.log(`[DEBUG] Created word card: "${card.word}"`);
      } else if (cardType === 'phrase') {
        const card = this.createPhraseCard(content);
        this.cards.push(card);
        if (this.debug) console.log(`[DEBUG] Created phrase card: "${card.word}"`);
      }
    }

    /**
     * Determine card type based on content and context
     */
    determineCardType(content, indentLevel) {
      // Check if in phrase list (è§„åˆ™4: - è¯ç»„ or ## è¯ç»„)
      if (this.inPhraseList || this.inPhraseHeader) return 'phrase';

      // Check if content has POS marker
      if (this.hasPosMarker(content)) return 'word';

      // Check if content has IPA (word with pronunciation only)
      if (this.hasIpaMarker(content)) return 'word';

      // Check if first child has POS (inherit from child)
      if (this.firstChildHasPos(content, indentLevel)) return 'word';

      // Otherwise, it's a sentence
      return 'sentence';
    }

    /**
     * Process sentence - extract words/phrases and create sentence card
     */
    processSentence(content, indentLevel, lineIndex) {
      const extractedCards = [];

      // Step 1: Remove ** markers
      let clean = content.replace(/\*\*/g, '');

      // Step 1.5: Remove standalone * marks (not part of *word(def)* pattern)
      // This prevents matching *word inside other *word(def)* patterns
      clean = clean.replace(/\*([a-zA-Z'-]+)\*/g, '$1');  // Remove * around single words

      // Step 2: Extract *word(pos. definition)* patterns
      clean = this.extractItalicWords(clean, extractedCards);

      // Step 3: Extract <ins>phrase</ins> patterns
      clean = this.extractInsPhrases(clean, extractedCards);

      // Step 4: Process children (extracted words/phrases go before sentence)
      this.pendingSynonyms = [];  // Reset for this sentence
      const childrenCards = this.processChildren(indentLevel, lineIndex);
      extractedCards.push(...childrenCards);

      // Add extracted cards before the sentence
      extractedCards.forEach(card => {
        this.cards.push(card);
      });

      // Step 5: Split English and Chinese
      // Find the first Chinese character or full-width parenthesis
      const cnMatch = clean.match(/[\u4e00-\u9fa5\uff08-\uff9e]/);
      let en = clean;
      let cn = '';

      if (cnMatch) {
        const cnIndex = clean.indexOf(cnMatch[0]);
        en = clean.substring(0, cnIndex).trim();
        cn = clean.substring(cnIndex).trim();
      }

      // Create sentence card
      const sentenceCard = {
        id: `card_${this.cardCounter++}`,
        word: clean.substring(0, 50) + (clean.length > 50 ? '...' : ''),
        type: 'sentence',
        fullText: clean,  // Required for rendering
        items: [{type: 'sentence', en: en, cn: cn}]
      };

      // Add synonyms if any
      if (this.pendingSynonyms && this.pendingSynonyms.length > 0) {
        sentenceCard.synonyms = this.pendingSynonyms.map(word => ({word}));
      }

      this.cards.push(sentenceCard);
      this.parentCard = sentenceCard;
      this.parentLevel = indentLevel;
    }

    /**
     * Process children of a sentence
     */
    processChildren(parentIndentLevel, lineIndex) {
      const children = [];
      let i = lineIndex + 1;

      while (i < this.lines.length) {
        const line = this.lines[i];
        const trimmed = line.trim();

        if (!trimmed) {
          i++;
          continue;
        }

        const indentMatch = line.match(/^(\s*)-/);
        if (!indentMatch) break; // Not a list item
        const indentLevel = indentMatch[1].length;

        // Exit if not a child (same level or higher)
        if (indentLevel <= parentIndentLevel) break;

        const content = trimmed.substring(1).trim();

        // Check if it's a synonym marker
        if (this.isSynonymMarker(content)) {
          // Add to parent sentence's synonyms
          const synonymWord = content.replace(/^===?\s+/, '').trim();
          // Will be added to sentence card after it's created
          if (!this.pendingSynonyms) {
            this.pendingSynonyms = [];
          }
          this.pendingSynonyms.push(synonymWord);
          i++;
          continue;
        }

        // Check if it's a pure POS line - skip (belongs to previous sibling)
        if (this.isPurePosLine(content)) {
          i++;
          continue;
        }

        // Check if it's a pure IPA line - skip (belongs to previous sibling)
        if (this.isPureIpaLine(content)) {
          i++;
          continue;
        }

        // Determine card type for this child
        const cardType = this.determineCardType(content, indentLevel);

        // Create the appropriate card
        if (cardType === 'word') {
          children.push(this.createWordCard(content, indentLevel));
        } else if (cardType === 'phrase') {
          children.push(this.createPhraseCard(content));
        } else {
          // Sentence - shouldn't happen at level 8, but handle it
          const sentenceCard = {
            id: `card_${this.cardCounter++}`,
            word: content,
            type: 'sentence',
            fullText: content,  // Required for rendering
            items: [{type: 'sentence', en: content, cn: ''}]
          };
          children.push(sentenceCard);
        }

        i++;
      }

      return children;
    }

    /**
     * Extract *word(pos. definition)* patterns from sentence
     */
    extractItalicWords(text, extractedCards) {
      // Match *word(def)* format - use lazy quantifier to stop at first )*
      return text.replace(/\*([a-zA-Z'-]+)\(([^*]*?)\)\*/g, (match, word, def) => {
        // Debug log
        console.log('extractItalicWords match:', {
          match: match,
          word: word,
          def: def
        });

        // Check if definition has POS
        if (this.hasPosMarker(def)) {
          extractedCards.push(this.createWordCard(`${word} ${def}`, 0));
        }
        return word;
      });
    }

    /**
     * Extract <ins>phrase</ins> patterns from sentence
     */
    extractInsPhrases(text, extractedCards) {
      return text.replace(/<ins>(.*?)<\/ins>/g, (match, phrase) => {
        const cleanPhrase = phrase.replace(/\*/g, '').trim();
        extractedCards.push(this.createPhraseCard(cleanPhrase));
        return cleanPhrase;
      });
    }

    /**
     * Create word card
     */
    createWordCard(content, indentLevel) {
      const {word, ipa, pos, cn} = this.parseWordContent(content);
      const card = {
        id: `card_${this.cardCounter++}`,
        word: word,
        type: 'word',
        items: []
      };

      // Only add ipa if it exists
      if (ipa) {
        card.ipa = ipa;
      }

      // Add items if pos exists
      if (pos) {
        card.items.push({type: 'def', en: pos, cn: cn || ''});
      }

      // Always update parent reference (this card becomes the parent for its children)
      this.parentCard = card;
      this.parentLevel = indentLevel;

      return card;
    }

    /**
     * Create phrase card
     */
    createPhraseCard(content) {
      const {word, cn} = this.parsePhraseContent(content);
      const card = {
        id: `card_${this.cardCounter++}`,
        word: word,
        type: 'phrase',
        items: [{type: 'def', en: word, cn: cn || ''}]
      };

      // Update parent reference
      this.parentCard = card;
      this.parentLevel = 4;  // Phrase cards are typically at level 4

      return card;
    }

    /**
     * Parse word content to extract word, ipa, pos, and cn
     * Supports formats:
     * - word [ipa] pos. cn
     * - word pos. cn
     * - word ï¼ˆnotesï¼‰cn
     */
    parseWordContent(content) {
      let word = content;
      let ipa = '';
      let pos = '';
      let cn = '';

      console.log('parseWordContent input:', content);

      // Extract IPA first (remove it from content)
      const ipaMatch = content.match(/\[([^\]]+)\]|\/([^\/]+)\//);
      if (ipaMatch) {
        ipa = ipaMatch[0];
        word = word.replace(ipa, '').trim();
        console.log('After IPA extraction:', {word, ipa});
      }

      // Check if there's a POS marker (like "n.", "v.", "adj." etc)
      // Format: word pos. definition (posåé¢å¯ä»¥æ˜¯ç©ºæ ¼æˆ–ç›´æ¥ä¸­æ–‡)
      const posMatch = word.match(/\s([a-z]+\.)/);
      console.log('POS match result:', posMatch);
      if (posMatch) {
        // Found a POS marker - extract word before it
        const posIndex = word.indexOf(posMatch[1]);
        pos = posMatch[1];

        // Extract Chinese definition BEFORE modifying word
        cn = word.substring(posIndex + posMatch[1].length).trim();

        // Now modify word
        word = word.substring(0, posIndex).trim();
        console.log('After POS extraction:', {word, pos, cn});
      } else {
        // No POS marker - check if there's Chinese
        const cnMatch = word.match(/[\u4e00-\u9fa5\uff08-\uff9e]/);
        if (cnMatch) {
          cn = word.substring(word.indexOf(cnMatch[0])).trim();
          word = word.substring(0, word.indexOf(cnMatch[0])).trim();
        }
      }

      console.log('parseWordContent output:', {word, ipa, pos, cn});
      return {word, ipa, pos, cn};
    }

    /**
     * Parse phrase content to extract phrase and Chinese
     */
    parsePhraseContent(content) {
      const cnMatch = content.match(/[\u4e00-\u9fa5]+/);
      if (cnMatch) {
        const cnStart = content.indexOf(cnMatch[0]);
        return {
          word: content.substring(0, cnStart).trim(),
          cn: content.substring(cnStart).trim()
        };
      }
      return {word: content, cn: ''};
    }

    /**
     * Check if it's a synonym marker (== word)
     */
    isSynonymMarker(content) {
      return /^===?\s+/.test(content);
    }

    /**
     * Check if it's a pure POS line (n. ä¸­æ–‡)
     */
    isPurePosLine(content) {
      const trimmed = content.trim();
      // Match: n./v./adj./adv./vt./vi. + optional space + Chinese
      // Examples: "n. å¿ƒæ€", "vi. ï¼ˆæ­£å¼æ–‡ä»¶ï¼‰åˆ°æœŸ", "adj. ä¸æ‹¥æŒ¤çš„"
      const result = /^[a-z]+\.\s*[\u4e00-\u9fa5\(\uff08]/.test(trimmed);
      if (this.debug && result) {
        console.log(`[DEBUG] isPurePosLine: TRUE for "${content}"`);
      }
      return result;
    }

    /**
     * Check if it's a pure IPA line ([éŸ³æ ‡])
     */
    isPureIpaLine(content) {
      return /^(\[[^\]]+\]|\/[^\/]+\/)$/.test(content.trim());
    }

    /**
     * Check if content has POS marker
     */
    hasPosMarker(content) {
      return /\s+(?!sb\.|sth\.)([a-z]+\.)/.test(content);
    }

    /**
     * Check if content has IPA marker (word with pronunciation)
     */
    hasIpaMarker(content) {
      return /(\[[^\]]+\]|\/[^\/]+\/)/.test(content);
    }

    /**
     * Check if first child has POS
     */
    firstChildHasPos(content, indentLevel) {
      // Find the current line index
      let currentLineIndex = -1;
      for (let i = 0; i < this.lines.length; i++) {
        const line = this.lines[i];
        const trimmed = line.trim();
        if (trimmed.startsWith('-')) {
          const lineContent = trimmed.substring(1).trim();
          if (lineContent === content) {
            const lineIndentMatch = line.match(/^(\s*)-/);
            const lineIndentLevel = lineIndentMatch ? lineIndentMatch[1].length : 0;
            if (lineIndentLevel === indentLevel) {
              currentLineIndex = i;
              break;
            }
          }
        }
      }

      if (currentLineIndex === -1) return false;

      // Look at next lines to find first child with greater indent
      for (let i = currentLineIndex + 1; i < this.lines.length; i++) {
        const line = this.lines[i];
        const trimmed = line.trim();

        // Skip empty lines
        if (!trimmed) continue;

        // Check if it's a list item
        if (!trimmed.startsWith('-')) break;

        // Check indent level
        const indentMatch = line.match(/^(\s*)-/);
        if (!indentMatch) break;

        const nextIndentLevel = indentMatch[1].length;

        // Exit if not a child (same level or higher)
        if (nextIndentLevel <= indentLevel) break;

        // This is a child - check if it has POS
        const nextContent = trimmed.substring(1).trim();
        return this.isPurePosLine(nextContent) || this.hasPosMarker(nextContent);
      }

      return false;
    }

    /**
     * Add synonym to parent card
     */
    addSynonymToParent(content) {
      if (this.parentCard) {
        const synonymWord = content.replace(/^===?\s+/, '').trim();
        this.parentCard.synonyms = this.parentCard.synonyms || [];
        this.parentCard.synonyms.push({word: synonymWord});
      }
    }

    /**
     * Add POS definition to parent card
     */
    addPosToParent(content) {
      if (this.parentCard) {
        const posMatch = content.match(/^([a-z]+\.)\s*(.*)/);
        if (posMatch) {
          const pos = posMatch[1];
          const rest = posMatch[2];

          // Simply use all text after POS as the Chinese definition
          // This includes Chinese, English notes in parentheses like "ï¼ˆå¸¸pl. ï¼‰", emoji, etc.
          const cn = rest.trim();

          this.parentCard.items.push({
            type: 'def',
            en: pos,
            cn: cn
          });
        }
      }
    }

    /**
     * Add IPA to parent card
     */
    addIpaToParent(content) {
      if (this.parentCard && !this.parentCard.ipa) {
        this.parentCard.ipa = content.trim();
      }
    }

    /**
     * Check if header is a valid word
     */
    isValidWordHeader(text) {
      if (/^(Words|è¯ç»„|å¥å¼|Unit|\d+)/.test(text)) return false;
      return /^[a-zA-Z]/.test(text);
    }

    /**
     * Create a basic card (used for headers)
     */
    createCard(word, type) {
      const card = {
        id: `card_${this.cardCounter++}`,
        word: word,
        type: type,
        items: []
      };
      return card;
    }
  }

  /**
   * MAIN APP
   */
  class VocabApp {
    constructor() {
      this.ui = {
        loader: document.getElementById('loader'),
        card: document.getElementById('cardContainer'),
        word: document.getElementById('displayWord'),
        ipa: document.getElementById('displayPronunciation'),
        badges: document.getElementById('displayBadges'),
        list: document.getElementById('itemList'),
        progress: document.getElementById('progressText'),
        statsList: document.getElementById('wordListContainer'),
        actionArea: document.getElementById('actionArea'),
        statsPanel: document.getElementById('statsPanel'),
        filePanel: document.getElementById('filePanel'),
        fileListContainer: document.getElementById('fileListContainer'),
        btnInput: document.getElementById('btnModeInput'),
        btnRecall: document.getElementById('btnModeRecall'),
        btnPrev: document.getElementById('btnPrev'),
        confirmDialog: document.getElementById('confirmDialog'),
        dialogMessage: document.getElementById('dialogMessage'),
        dialogConfirmBtn: document.getElementById('dialogConfirmBtn'),
        currentFileDisplay: document.getElementById('currentFileDisplay')
      };
      this.init();
    }

    async init() {
      // TEMPORARY: Test the genuinely case
      const testMarkdown = `## inherent
- [ÉªnËˆhÉªÉ™rÉ™nt]
- adj. å›½æœ‰çš„ï¼Œå†…åœ¨çš„
- inherent in sth æŸç‰©ä¸­å›ºæœ‰çš„ã€å¯†ä¸å¯åˆ†çš„ã€ä¸å¯é¿å…çš„
- Commitment is **inherent** in any *genuinely([ËˆdÊ’É›njÊŠÉªnlÉª] adv. çœŸæ­£åœ°ã€è¯šæŒšåœ°)* loving relationship.`;
      console.log('=== TESTING GENUINELY CASE ===');
      const parser = new MarkdownParser(testMarkdown);
      const cards = parser.parse();
      console.log('Result:', cards);
      console.log('=== END TEST ===');

      // Initialize speech synthesis voices
      if ('speechSynthesis' in window) {
        // Load voices (some browsers need this)
        if (speechSynthesis.onvoiceschanged !== undefined) {
          speechSynthesis.onvoiceschanged = () => {
            // Voices loaded, pre-warm the synthesis engine
            this.prewarmSpeechSynthesis();
          };
        }
        // Also try to pre-warm immediately if voices are already available
        this.prewarmSpeechSynthesis();
      }

      // Force clear ALL cache on init to avoid old format issues
      console.log('ğŸ—‘ï¸ Clearing all file cache to fix format issues');
      const cacheKeys = Object.keys(localStorage);
      cacheKeys.forEach(key => {
        if (key.startsWith(CONFIG.cacheKey)) {
          localStorage.removeItem(key);
        }
      });

      this.loadState();
      console.log('init - STATE.cards.length:', STATE.cards.length, 'currentPath:', STATE.currentPath);

      if (STATE.cards.length === 0) {
        // Check if we have a saved file path
        if (STATE.currentPath) {
          console.log('init - Loading saved file:', STATE.currentPath);
          await this.loadFile(STATE.currentPath);
        } else {
          console.log('init - No saved file, showing file selection');
          // Show file selection panel
          this.toggleFiles(true);
          await this.loadRootFolders();
        }
      } else {
        console.log('init - Rendering existing cards');
        // Update current file display
        if (STATE.currentPath) {
          this.updateCurrentFileDisplay(STATE.currentPath);
        }
        this.render();
      }
      this.updateStatsUI();
    }

    updateCurrentFileDisplay(path) {
      // Update current file name in header (remove .md extension)
      const pathParts = path.split('/');
      const fileName = pathParts.pop().replace('.md', '');
      const directory = pathParts.length > 0 ? pathParts[0].charAt(0).toUpperCase() + pathParts[0].slice(1) : '';
      const displayText = directory ? `${directory} / ${fileName}` : fileName;

      console.log('ğŸ“ Updating file display:', {path, displayText, element: this.ui.currentFileDisplay});
      this.ui.currentFileDisplay.textContent = displayText;

      // Update mobile title bar
      const fileTitleText = document.getElementById('fileTitleText');
      if (fileTitleText) {
        fileTitleText.textContent = displayText;
        console.log('ğŸ“ Updating mobile title bar:', displayText);
      }
    }

    async fetchData() {
      // This method is deprecated, use loadFile instead
      console.warn('fetchData is deprecated, use loadFile');
    }

    async loadFile(path) {
      try {
        console.log('å¼€å§‹åŠ è½½æ–‡ä»¶:', path);
        // Show loader
        this.ui.loader.classList.remove('hidden');
        this.ui.card.classList.add('hidden');

        // Handle full paths from GitHub API (e.g., "english/word/core/Unit1-1.md" -> "core/Unit1-1.md")
        const relativePath = path.startsWith('english/word/') ? path.substring('english/word/'.length) : path;
        console.log('ğŸ“ Relative path for fetch:', relativePath);
        const text = await GitHubApi.fetchFileContent(relativePath);
        console.log('æ–‡ä»¶åŠ è½½å®Œæˆï¼Œé•¿åº¦:', text.length);

        if (!text || text.trim().length === 0) {
          throw new Error('æ•°æ®ä¸ºç©º');
        }

        console.log('å¼€å§‹è§£æ...');
        const parser = new MarkdownParser(text);
        STATE.cards = parser.parse();
        console.log('è§£æå®Œæˆï¼Œå¡ç‰‡æ•°é‡:', STATE.cards.length);

        if (STATE.cards.length === 0) {
          throw new Error('è§£æåæ²¡æœ‰ç”Ÿæˆä»»ä½•å¡ç‰‡ï¼Œè¯·æ£€æŸ¥æ•°æ®æ ¼å¼');
        }

        // Save relative path and load stats for this file
        STATE.currentPath = relativePath;
        this.loadStatsForFile(relativePath);

        this.saveState();
        this.ui.loader.classList.add('hidden');
        this.ui.card.classList.remove('hidden');

        // Update current file name in header (remove .md extension)
        this.updateCurrentFileDisplay(relativePath);

        this.render();
        this.showToast(`è§£æå®Œæˆï¼š${STATE.cards.length} å¼ å¡ç‰‡`);
      } catch (e) {
        console.error('åŠ è½½å¤±è´¥:', e);
        let errorMsg = e.message;
        if (e.name === 'AbortError') {
          errorMsg = 'è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
        }
        this.ui.loader.innerHTML = `
          <div style="text-align: center; padding: 2rem;">
            <p style="color:red; font-size: 1.1rem; margin-bottom: 1rem;">åŠ è½½å¤±è´¥: ${errorMsg}</p>
            <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æ•°æ®æº</p>
            <p style="color: #999; font-size: 0.8rem; margin-bottom: 1rem;">è·¯å¾„: ${path}</p>
            <button class="btn-primary" onclick="location.reload()" style="margin-top: 1rem;">é‡æ–°åŠ è½½</button>
          </div>
        `;
      }
    }

    render() {
      if (STATE.cards.length === 0) return;
      const card = STATE.cards[STATE.currentIndex];

      // Ensure card has required fields (for backward compatibility)
      if (!card.items) card.items = [];
      if (!card.synonyms) card.synonyms = [];
      if (!card.emoji) card.emoji = '';

      const stats = STATE.stats[card.id] || {errors: 0};

      // Add/remove type-specific classes
      this.ui.card.classList.remove('is-sentence', 'is-phrase');
      if (card.type === 'sentence') {
        this.ui.card.classList.add('is-sentence');
      } else if (card.type === 'phrase') {
        this.ui.card.classList.add('is-phrase');
      }

      // Header
      // Add play button for word pronunciation
      const wordEscaped = card.word.replace(/'/g, '\\\'');
      const playButton = `<button class="btn-ghost" onclick="app.playWord('${wordEscaped}')" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;" title="æ’­æ”¾å‘éŸ³">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polygon points="5 3 19 12 5 21 5 3"></polygon>
        </svg>
      </button>`;
      this.ui.word.innerHTML = `<span>${card.word}</span> ${playButton}`;
      this.ui.ipa.textContent = ''; // ä¸æ˜¾ç¤ºéŸ³æ ‡
      this.ui.ipa.style.display = 'none'; // å®Œå…¨éšè—éŸ³æ ‡å…ƒç´ 
      // Badges
      let bHtml = '';
      if (card.type === 'word') bHtml += `<span class="badge badge-word">å•è¯</span>`;
      else if (card.type === 'phrase') bHtml += `<span class="badge badge-rel">è¯ç»„</span>`;
      else if (card.type === 'sentence') bHtml += `<span class="badge badge-sent">ä¾‹å¥</span>`;
      if (stats.errors > 0) bHtml += `<span class="badge badge-err">é”™ ${stats.errors}</span>`;
      this.ui.badges.innerHTML = bHtml;
      // Items
      this.ui.list.innerHTML = '';

      // Special rendering for phrase cards
      if (card.type === 'phrase') {
        // Create wrapper for title and badges
        const wrapper = document.createElement('div');
        wrapper.className = 'phrase-header-wrapper';

        // Add phrase title on the left
        const titleDiv = document.createElement('div');
        titleDiv.className = 'phrase-title';
        titleDiv.innerHTML = `${card.word} ${playButton}`;
        wrapper.appendChild(titleDiv);

        // Add badges on the right
        if (bHtml) {
          const badgesDiv = document.createElement('div');
          badgesDiv.className = 'badges-container';
          badgesDiv.innerHTML = bHtml;
          wrapper.appendChild(badgesDiv);
        }

        this.ui.list.appendChild(wrapper);
      }

      // Special rendering for sentence cards
      if (card.type === 'sentence') {
        const li = document.createElement('li');
        li.className = 'item';

        // Add sentence label
        const labelDiv = document.createElement('div');
        labelDiv.className = 'sentence-label';
        labelDiv.textContent = 'Example Sentence';
        this.ui.list.appendChild(labelDiv);

        // Display sentence patterns (if any)
        if (card.patterns && card.patterns.length > 0) {
          const patternsDiv = document.createElement('div');
          patternsDiv.className = 'sentence-patterns';
          patternsDiv.style.cssText = 'margin-bottom: 1rem; padding: 0.75rem 1rem; background: #fef3c7; border-left: 3px solid #f59e0b; border-radius: 4px; font-size: 0.9rem; color: #92400e;';

          card.patterns.forEach(pattern => {
            const patternP = document.createElement('div');
            patternP.style.cssText = 'margin: 0.25rem 0; line-height: 1.5;';
            patternP.textContent = `ğŸ“Œ ${pattern}`;
            patternsDiv.appendChild(patternP);
          });

          this.ui.list.appendChild(patternsDiv);
        }

        // Display only the English part of the sentence
        // card.items[0].en contains the pure English text (without Chinese)
        const sentenceHtml = card.items[0].en;

        const contentDiv = document.createElement('div');
        contentDiv.className = 'sentence-content';
        contentDiv.innerHTML = sentenceHtml;
        this.ui.list.appendChild(contentDiv);

        // Add Chinese translation if exists
        const item = card.items[0];
        const hasChinese = item.cn && typeof item.cn.trim === 'function' && item.cn.trim() !== '';

        if (hasChinese) {
          const cnDiv = document.createElement('div');
          cnDiv.className = 'sentence-cn';
          cnDiv.id = 'sentenceCn';  // Add ID for easy access
          cnDiv.textContent = item.cn;

          // IMPORTANT: Always hide Chinese initially for sentences (regardless of mode)
          // User must click "æŸ¥çœ‹è¯‘æ–‡" button to reveal it
          cnDiv.style.display = 'none';

          this.ui.list.appendChild(cnDiv);
        }

        this.ui.list.appendChild(li);
      } else {
        // Normal rendering for word cards
        const items = card.items;
        items.forEach((item, idx) => {
          const li = document.createElement('li');
          li.className = 'item';
          const cleanEn = item.en
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*/g, ''); // remove remaining italics for clean look

          // Check if en field is a POS (part of speech) or just the word itself
          // POS patterns: adj., adv., n., v., vt., vi., prep., conj., etc.
          const hasPOS = /^[a-z]+\.$/.test(cleanEn.trim());

          // å‡†å¤‡ä¸­æ–‡å†…å®¹
          const hasCn = item.cn && item.cn.trim && item.cn.trim() !== '';
          // å¦‚æœæ²¡æœ‰ä¸­æ–‡ï¼Œä¸æ˜¾ç¤ºä»»ä½•å†…å®¹ï¼ˆåŒ…æ‹¬"ç‚¹å‡»æŸ¥çœ‹ä¸­æ–‡"ï¼‰
          let cnHtml = '';
          let cnDisplay = '';  // Initialize cnDisplay for all branches
          if (hasCn) {
            cnDisplay = item.cn;
            // Add emoji to first Chinese definition if exists
            if (idx === 0 && card.emoji) {
              cnDisplay = card.emoji + ' ' + cnDisplay;
            }

            cnHtml = `<div class="cn-text" onclick="app.reveal(this)" data-has-cn="true">${cnDisplay}</div>`;
          }

          // If no POS, don't show en-text (only show Chinese if exists)
          // If has POS, show both en-text (POS) and Chinese
          if (hasPOS || !hasCn) {
            // Show en-text only if it's a POS, or if there's no Chinese (fallback)
            // BUT for phrases: if en is the phrase itself, don't show it (only show chinese)
            const isPhraseItself = card.type === 'phrase' && item.en === card.word;

            if (isPhraseItself && !hasCn) {
              // Phrase without definition - skip this item entirely
              return; // Don't append this li
            }

            if (isPhraseItself && hasCn) {
              // Phrase with definition - only show Chinese
              li.innerHTML = `<div class="cn-text" onclick="app.reveal(this)" data-has-cn="true">${cnDisplay}</div>`;
            } else {
              // Word or POS - show both
              li.innerHTML = `
                              <span class="item-tag tag-def ${STATE.mode === 'recall' ? 'blur-target' : ''}"></span>
                              <div class="en-text ${STATE.mode === 'recall' ? 'blur-target' : ''}">${cleanEn}</div>
                              ${cnHtml}
                          `;
            }
          } else {
            // Only show Chinese, hide en-text (which is just the word itself)
            li.innerHTML = `<div class="cn-text" onclick="app.reveal(this)" data-has-cn="true" style="border-left: none; padding-left: 0;">${cnDisplay}</div>`;
          }
          this.ui.list.appendChild(li);
        });

        // Add synonyms section if exists
        const hasSynonyms = card.synonyms && card.synonyms.length > 0;
        const hasAntonyms = card.antonyms && card.antonyms.length > 0;

        if (hasSynonyms || hasAntonyms) {
          // Render synonyms
          if (hasSynonyms) {
            const synSection = document.createElement('div');
            synSection.className = 'synonyms-section';

            const synLabel = document.createElement('div');
            synLabel.className = 'synonyms-label';
            synLabel.textContent = 'Synonyms';
            synSection.appendChild(synLabel);

            const synList = document.createElement('div');
            synList.className = 'synonyms-list';

            card.synonyms.forEach(syn => {
              const synItem = document.createElement('span');
              synItem.className = 'synonym-item';

              // Play button
              const playBtn = document.createElement('button');
              playBtn.className = 'synonym-play-btn';
              playBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>`;
              const synWordEscaped = syn.word.replace(/'/g, '\\\'');
              playBtn.onclick = () => app.playWord(synWordEscaped);

              const synWord = document.createElement('span');
              synWord.className = 'synonym-word';

              // Build synonym display: word + pos (if exists) + def (if exists)
              let synDisplay = syn.word;
              if (syn.pos && syn.pos.trim() !== '') {
                synDisplay += ` ${syn.pos}`;
              }
              synWord.textContent = synDisplay;

              synItem.appendChild(playBtn);
              synItem.appendChild(synWord);

              // Only add definition if it exists (and is not included in pos)
              if (syn.def && syn.def.trim() !== '') {
                const synDef = document.createElement('span');
                synDef.className = 'synonym-def';
                synDef.textContent = syn.def;
                synItem.appendChild(synDef);
              }

              synList.appendChild(synItem);
            });

            synSection.appendChild(synList);
            this.ui.list.appendChild(synSection);
          }

          // Render antonyms
          if (hasAntonyms) {
            const antSection = document.createElement('div');
            antSection.className = 'synonyms-section';

            const antLabel = document.createElement('div');
            antLabel.className = 'synonyms-label';
            antLabel.style.color = '#ef4444';  // Red for antonyms
            antLabel.textContent = 'Antonyms (åä¹‰è¯)';
            antSection.appendChild(antLabel);

            const antList = document.createElement('div');
            antList.className = 'synonyms-list';

            card.antonyms.forEach(ant => {
              const antItem = document.createElement('span');
              antItem.className = 'synonym-item';
              antItem.style.background = '#fee2e2';  // Red background for antonyms

              // Play button
              const playBtn = document.createElement('button');
              playBtn.className = 'synonym-play-btn';
              playBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
              </svg>`;
              const antWordEscaped = ant.word.replace(/'/g, '\\\'');
              playBtn.onclick = () => app.playWord(antWordEscaped);

              const antWord = document.createElement('span');
              antWord.className = 'synonym-word';
              antWord.style.color = '#dc2626';  // Red text for antonyms

              // Build antonym display: word + pos (if exists) + def (if exists)
              let antDisplay = ant.word;
              if (ant.pos && ant.pos.trim() !== '') {
                antDisplay += ` ${ant.pos}`;
              }
              antWord.textContent = antDisplay;

              antItem.appendChild(playBtn);
              antItem.appendChild(antWord);

              // Only add definition if it exists (and is not included in pos)
              if (ant.def && ant.def.trim() !== '') {
                const antDef = document.createElement('span');
                antDef.className = 'synonym-def';
                antDef.textContent = ant.def;
                antItem.appendChild(antDef);
              }

              antList.appendChild(antItem);
            });

            antSection.appendChild(antList);
            this.ui.list.appendChild(antSection);
          }
        }
      }
      // Progress
      this.ui.progress.textContent = `${STATE.currentIndex + 1} / ${STATE.cards.length}`;
      // Mode Actions
      if (STATE.mode === 'recall') {
        document.body.classList.add('mode-recall');
        this.ui.btnInput.classList.remove('active');
        this.ui.btnRecall.classList.add('active');
        this.ui.btnPrev.classList.remove('hidden'); // Show prev button in recall mode
        this.renderRecallActions();
      } else {
        document.body.classList.remove('mode-recall');
        this.ui.btnInput.classList.add('active');
        this.ui.btnRecall.classList.remove('active');
        this.ui.btnPrev.classList.remove('hidden');
        this.renderInputActions();
      }
    }

    renderInputActions() {
      const card = STATE.cards[STATE.currentIndex];

      // For sentence cards with Chinese translation, show special buttons
      if (card.type === 'sentence') {
        const hasChinese = card.items[0].cn && typeof card.items[0].cn.trim === 'function' && card.items[0].cn.trim() !== '';

        if (hasChinese) {
          // Sentence with Chinese: check if Chinese is visible
          const cnDiv = document.getElementById('sentenceCn');
          const isCnVisible = cnDiv && cnDiv.style.display !== 'none';

          if (!isCnVisible) {
            // Chinese is hidden: show "æŸ¥çœ‹è¯‘æ–‡" button
            this.ui.actionArea.innerHTML = `
              <button class="btn-primary" onclick="app.showSentenceTranslation()">æŸ¥çœ‹è¯‘æ–‡ <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg></button>
            `;
          } else {
            // Chinese is visible: show "ä¸‹ä¸€ä¸ª" button
            this.ui.actionArea.innerHTML = `<button class="btn-primary" onclick="app.nextCard()">ä¸‹ä¸€ä¸ª <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg></button>`;
          }
          return;
        }
      }

      // Default: show "ä¸‹ä¸€ä¸ª" button
      this.ui.actionArea.innerHTML = `<button class="btn-primary" onclick="app.nextCard()">ä¸‹ä¸€ä¸ª <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg></button>`;
    }

    renderRecallActions() {
      const card = STATE.cards[STATE.currentIndex];

      // For sentence cards with Chinese translation, show special buttons
      if (card.type === 'sentence') {
        const hasChinese = card.items[0].cn && typeof card.items[0].cn.trim === 'function' && card.items[0].cn.trim() !== '';

        if (!hasChinese) {
          // No Chinese translation, just show next button
          this.renderNextAction();
          return;
        }

        // Sentence with Chinese: check if Chinese is visible
        const cnDiv = document.getElementById('sentenceCn');
        const isCnVisible = cnDiv && cnDiv.style.display !== 'none';

        if (!isCnVisible) {
          // Chinese is hidden: show "æŸ¥çœ‹è¯‘æ–‡" and "è·³è¿‡" buttons
          this.ui.actionArea.innerHTML = `
            <button class="btn-ghost" onclick="app.nextCard()">è·³è¿‡</button>
            <button class="btn-primary" onclick="app.showSentenceTranslation()">æŸ¥çœ‹è¯‘æ–‡</button>
          `;
        } else {
          // Chinese is visible: show "ç†è§£æ­£ç¡®" and "ç†è§£é”™è¯¯" buttons
          this.ui.actionArea.innerHTML = `
            <button class="btn-danger" onclick="app.handleSentenceRecall(false)">ç†è§£é”™è¯¯</button>
            <button class="btn-success" onclick="app.handleSentenceRecall(true)">ç†è§£æ­£ç¡®</button>
          `;
        }
        return;
      }

      // For word cards or phrases: check if they have Chinese definitions
      // If no Chinese, show "ä¸‹ä¸€ä¸ª" button directly
      const hasChinese = card.items && card.items.some(item =>
        item.cn && item.cn.trim && item.cn.trim() !== ''
      );

      if (!hasChinese) {
        // No Chinese translation: just show next button
        this.renderNextAction();
        return;
      }

      // Has Chinese: show standard recall buttons
      this.ui.actionArea.innerHTML = `
        <button class="btn-success" onclick="app.handleRecall(true)">è®°å¾—</button>
        <button class="btn-danger" onclick="app.handleRecall(false)">ä¸è®°å¾—</button>
      `;
    }

    renderConfirmationActions() {
      // State 2: Definition Revealed, User Needs to Verify
      this.ui.actionArea.innerHTML = `
	                    <button class="btn-danger" onclick="app.confirmRecall(false)">å…¶å®ä¸ä¼š</button>
	                    <button class="btn-success" onclick="app.confirmRecall(true)">ç¡®è®¤æŒæ¡</button>
	                `;
    }

    renderNextAction() {
      // State 3: Just go to next
      this.ui.actionArea.innerHTML = `<button class="btn-primary" onclick="app.nextCard()">ä¸‹ä¸€ä¸ª</button>`;
    }

    reveal(el) {
      if (STATE.mode === 'recall') {
        // åœ¨é®æŒ¡æ¨¡å¼ä¸‹ï¼Œç‚¹å‡»åæ˜¾ç¤ºä¸­æ–‡ï¼ˆç§»é™¤æ¨¡ç³Šæ•ˆæœï¼‰
        el.classList.add('revealed');
      }
      // åœ¨æµè§ˆæ¨¡å¼ä¸‹ï¼Œä¸­æ–‡å·²ç»ç›´æ¥æ˜¾ç¤ºï¼Œä¸éœ€è¦é¢å¤–å¤„ç†
    }

    setMode(newMode) {
      STATE.mode = newMode;
      this.saveState();
      this.render();
    }

    handleRecall(claimedKnown) {
      // Always reveal definitions first
      this.revealAll();
      if (!claimedKnown) {
        // Don't remember -> Record Error immediately -> Show Next button
        this.recordError();
        this.showToast('å·²è®°å½•ä¸è®°å¾—');
        this.renderNextAction();
      } else {
        // Remember -> Show definition first, then offer verification
        // Switch buttons to "Yes/No" without blocking view
        this.renderConfirmationActions();
      }
    }

    confirmRecall(actuallyCorrect) {
      if (actuallyCorrect) {
        this.showToast('æ­£ç¡®ï¼');
        this.nextCard();
      } else {
        this.recordError();
        this.showToast('å·²è®°å½•é”™è¯¯');
        this.renderNextAction();
      }
    }

    revealAll() {
      document.querySelectorAll('.cn-text, .en-text').forEach(el => el.classList.add('revealed'));
      // Also reveal synonyms section
      const synonymsSection = document.querySelector('.synonyms-section');
      if (synonymsSection) {
        synonymsSection.classList.add('revealed');
      }
      // Reveal item-list (definition items)
      const itemList = document.querySelector('.item-list');
      if (itemList) {
        itemList.classList.add('revealed');
      }
    }

    recordError() {
      const id = STATE.cards[STATE.currentIndex].id;
      if (!STATE.stats[id]) STATE.stats[id] = {errors: 0};
      STATE.stats[id].errors++;
      this.saveState();
      this.updateStatsUI();
      // We don't re-render immediately here to avoid hiding the buttons if we are in a flow
      // But we might want to show the error badge. Let's update badges specifically.
      const card = STATE.cards[STATE.currentIndex];
      const stats = STATE.stats[card.id] || {errors: 0};
      let bHtml = document.getElementById('displayBadges').innerHTML;
      if (!bHtml.includes('é”™')) {
        bHtml += `<span class="badge badge-err">é”™ ${stats.errors}</span>`;
        document.getElementById('displayBadges').innerHTML = bHtml;
      }
    }

    showSentenceTranslation() {
      // Show the Chinese translation for the current sentence
      const cnDiv = document.getElementById('sentenceCn');
      if (cnDiv) {
        cnDiv.style.display = 'block';
        // Add 'revealed' class to remove blur and opacity effects in recall mode
        cnDiv.classList.add('revealed');
      }
      // Re-render buttons to show "ç†è§£æ­£ç¡®" and "ç†è§£é”™è¯¯"
      this.renderRecallActions();
    }

    handleSentenceRecall(understood) {
      // Handle user's understanding of the sentence
      if (!understood) {
        // User didn't understand correctly - record error
        this.recordError();
        this.showToast('å·²è®°å½•ç†è§£é”™è¯¯');
      } else {
        this.showToast('ç†è§£æ­£ç¡®ï¼');
      }
      // Move to next card
      this.nextCard();
    }

    nextCard() {
      if (STATE.currentIndex < STATE.cards.length - 1) {
        STATE.currentIndex++;
        this.render();
      } else {
        // Last card reached - show completion screen
        this.showCompletionScreen();
      }
    }

    showCompletionScreen() {
      // Calculate statistics
      const totalCards = STATE.cards.length;
      const totalErrors = Object.values(STATE.stats).reduce((sum, stat) => sum + stat.errors, 0);
      const accuracy = totalCards > 0 ? Math.round(((totalCards - totalErrors) / totalCards) * 100) : 100;

      // Show completion screen with confetti effect
      this.ui.card.innerHTML = `
        <div style="text-align: center; padding: 3rem 2rem;">
          <div style="font-size: 4rem; margin-bottom: 1rem;">ğŸ‰</div>
          <h2 style="font-size: 2rem; color: var(--primary); margin-bottom: 1rem;">å®Œç»“æ’’èŠ±ï¼</h2>
          <p style="font-size: 1.2rem; color: var(--text-sub); margin-bottom: 2rem;">
            æ­å–œä½ å®Œæˆäº†æ‰€æœ‰ ${totalCards} å¼ å¡ç‰‡ï¼
          </p>
          <div style="background: var(--card-bg); padding: 1.5rem; border-radius: 12px; margin-bottom: 2rem;">
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
              <div>
                <div style="font-size: 2rem; font-weight: 700; color: var(--primary);">${totalCards}</div>
                <div style="font-size: 0.875rem; color: var(--text-sub);">æ€»å¡ç‰‡</div>
              </div>
              <div>
                <div style="font-size: 2rem; font-weight: 700; color: var(--danger);">${totalErrors}</div>
                <div style="font-size: 0.875rem; color: var(--text-sub);">é”™è¯¯æ¬¡æ•°</div>
              </div>
              <div>
                <div style="font-size: 2rem; font-weight: 700; color: var(--success);">${accuracy}%</div>
                <div style="font-size: 0.875rem; color: var(--text-sub);">æ­£ç¡®ç‡</div>
              </div>
            </div>
          </div>
          <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
            <button class="btn-primary" onclick="app.restart()" style="font-size: 1.1rem; padding: 0.75rem 2rem;">
              ğŸ”„ é‡æ–°å¼€å§‹
            </button>
            <button class="btn-secondary" onclick="app.clearDataAndReload()" style="font-size: 1.1rem; padding: 0.75rem 2rem;">
              ğŸ—‘ï¸ æ¸…é™¤è¿›åº¦
            </button>
          </div>
        </div>
      `;

      // Hide action area and progress
      this.ui.actionArea.innerHTML = '';
      this.ui.progress.textContent = `${totalCards} / ${totalCards}`;

      // Trigger confetti effect
      this.triggerConfetti();
    }

    restart() {
      STATE.currentIndex = 0;
      this.render();
    }

    clearDataAndReload() {
      localStorage.removeItem(CONFIG.storageKey);
      location.reload();
    }

    triggerConfetti() {
      // Simple confetti effect using emojis
      const container = this.ui.card;
      const emojis = ['ğŸ‰', 'ğŸŠ', 'âœ¨', 'â­', 'ğŸŒŸ', 'ğŸ’«', 'ğŸˆ', 'ğŸ'];

      for (let i = 0; i < 30; i++) {
        setTimeout(() => {
          const confetti = document.createElement('div');
          confetti.textContent = emojis[Math.floor(Math.random() * emojis.length)];
          confetti.style.cssText = `
            position: absolute;
            font-size: ${Math.random() * 20 + 15}px;
            left: ${Math.random() * 100}%;
            top: -50px;
            animation: fall ${Math.random() * 2 + 2}s linear forwards;
            pointer-events: none;
            z-index: 1000;
          `;
          container.style.position = 'relative';
          container.appendChild(confetti);

          setTimeout(() => confetti.remove(), 4000);
        }, i * 50);
      }

      // Add animation keyframes if not exists
      if (!document.getElementById('confetti-style')) {
        const style = document.createElement('style');
        style.id = 'confetti-style';
        style.textContent = `
          @keyframes fall {
            to {
              transform: translateY(100vh) rotate(720deg);
              opacity: 0;
            }
          }
        `;
        document.head.appendChild(style);
      }
    }

    prevCard() {
      if (STATE.currentIndex > 0) {
        STATE.currentIndex--;
        this.render();
      }
    }

    /* --- SPEECH --- */
    prewarmSpeechSynthesis() {
      try {
        // Get voices to trigger initialization
        const voices = window.speechSynthesis.getVoices();

        // Speak a silent utterance to pre-warm the engine
        const utterance = new SpeechSynthesisUtterance('');
        utterance.volume = 0; // Silent
        window.speechSynthesis.speak(utterance);

        console.log('ğŸ”Š Speech synthesis pre-warmed');
      } catch (e) {
        console.warn('Failed to pre-warm speech synthesis:', e);
      }
    }

    async playWord(word, useTTSFallback = false) {
      if (!word) return;

      console.log('ğŸµ [PLAY] Request to play:', word, 'TTS:', useTTSFallback);

      // Priority: Local Audio â†’ Cambridge Dictionary â†’ Browser TTS
      if (!useTTSFallback) {
        // Try local audio first
        this.playLocalAudio(word).then(() => {
          console.log('âœ… [Local] Successfully played:', word);
          this.showToast('ğŸ”Š æ’­æ”¾ä¸­');
        }).catch((error) => {
          console.log('âš ï¸ [Local] Not available, trying Cambridge...', error);
          // Local audio not available, try Cambridge
          this.playCambridgeAudio(word).catch((error) => {
            console.warn('âš ï¸ [Cambridge] Failed, falling back to TTS:', error);
            // Both failed, use TTS as last resort
            this.showToast('ğŸ”Š ä½¿ç”¨æµè§ˆå™¨è¯­éŸ³...');
            this.playWord(word, true);
          });
        });
        return;
      }

      // Fallback: Use Web Speech API (browser TTS)
      if ('speechSynthesis' in window) {
        try {
          // Cancel any ongoing speech
          window.speechSynthesis.cancel();

          // Small delay to ensure cancel is complete (important for mobile)
          await new Promise(resolve => setTimeout(resolve, 50));

          const utterance = new SpeechSynthesisUtterance(word);
          utterance.lang = 'en-US';
          utterance.rate = 0.9; // Slightly slower for clarity
          utterance.pitch = 1;
          utterance.volume = 1;

          // Add event handlers for better debugging
          utterance.onstart = () => {
            console.log('ğŸ”Š [TTS] Playing:', word);
          };

          utterance.onerror = (event) => {
            console.warn('Speech synthesis error:', event.error);
            if (event.error === 'canceled') {
              // User canceled, not really an error
              return;
            }
            this.showToast('è¯­éŸ³æ’­æ”¾å¤±è´¥');
          };

          utterance.onend = () => {
            console.log('âœ… [TTS] Finished playing:', word);
          };

          // Try to use American English voice first
          const voices = window.speechSynthesis.getVoices();

          // If voices aren't loaded yet, they may be empty
          // Force load them
          if (voices.length === 0) {
            console.warn('No voices available, trying to reload...');
            // The onvoiceschanged event should trigger later
            window.speechSynthesis.getVoices();
          }

          const usVoice = voices.find(voice =>
            voice.lang === 'en-US'
          ) || voices.find(voice =>
            voice.lang.startsWith('en-US')
          ) || voices.find(voice =>
            voice.lang.startsWith('en') && voice.localService
          ) || voices.find(voice => voice.lang.startsWith('en'));

          if (usVoice) {
            utterance.voice = usVoice;
            console.log('ğŸ¤ [TTS] Using voice:', usVoice.name);
          } else {
            console.warn('No English voice found, using default');
          }

          window.speechSynthesis.speak(utterance);
        } catch (e) {
          console.error('Speech synthesis exception:', e);
          this.showToast('è¯­éŸ³æ’­æ”¾å‡ºé”™');
        }
      } else {
        this.showToast('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³æ’­æ”¾');
      }
    }

    /**
     * Play local audio from GitHub repository
     * @param {string} word - The word to pronounce
     * @returns {Promise} - Resolves when audio plays, rejects on error
     */
    async playLocalAudio(word) {
      try {
        // Clean the word: remove extra spaces, convert to lowercase
        const cleanWord = word.trim().toLowerCase().replace(/\s+/g, '-');
        const firstLetter = cleanWord.charAt(0);

        // Local audio URL (from your GitHub repository)
        const audioUrl = `${CONFIG.localAudioBaseUrl}/${firstLetter}/${cleanWord}.mp3`;

        console.log('ğŸµ [Local] Trying:', audioUrl);

        await this.playAudioUrl(audioUrl);
        return;
      } catch (error) {
        console.warn('Local audio failed:', error);
        throw error;
      }
    }

    /**
     * Play real human pronunciation from Cambridge Dictionary
     * Uses CORS proxy to avoid cross-origin issues on GitHub Pages
     * Tries multiple URL patterns and accents (US/UK)
     * @param {string} word - The word to pronounce
     * @returns {Promise} - Resolves when audio plays, rejects on error
     */
    async playCambridgeAudio(word) {
      try {
        // Clean the word: remove extra spaces, convert to lowercase
        const cleanWord = word.trim().toLowerCase().replace(/\s+/g, '-');
        const firstLetter = cleanWord.charAt(0);

        // Try multiple URL patterns in order
        const urlPatterns = [
          // US pronunciation (primary)
          `https://dictionary.cambridge.org/us/media/english/us_pron/${firstLetter}/${cleanWord}.mp3`,
          // UK pronunciation (secondary)
          `https://dictionary.cambridge.org/us/media/english/uk_pron/${firstLetter}/${cleanWord}.mp3`,
          // Alternative: sometimes words are in subfolders
          `https://dictionary.cambridge.org/us/media/english/us_pron/${firstLetter}/${cleanWord}_1.mp3`,
          `https://dictionary.cambridge.org/us/media/english/uk_pron/${firstLetter}/${cleanWord}_1.mp3`
        ];

        // Try each URL until one works
        for (const originalUrl of urlPatterns) {
          try {
            // Use CORS proxy to bypass cross-origin restrictions
            const proxiedUrl = CONFIG.corsProxy + encodeURIComponent(originalUrl);
            console.log('ğŸµ [Cambridge] Trying:', proxiedUrl);
            await this.playAudioUrl(proxiedUrl);
            console.log('âœ… [Cambridge] Successfully played:', cleanWord);
            return; // Success, exit
          } catch (err) {
            console.log('âš ï¸ [Cambridge] Failed:', originalUrl, err.message);
            // Try next URL
            continue;
          }
        }

        // All URLs failed
        throw new Error('No Cambridge audio available for this word');
      } catch (error) {
        console.error('Cambridge audio error:', error);
        throw error;
      }
    }

    /**
     * Play audio from URL with proper error handling
     * @param {string} url - Audio URL
     * @returns {Promise} - Resolves when audio plays
     */
    playAudioUrl(url) {
      return new Promise((resolve, reject) => {
        // Create audio element
        const audio = new Audio();

        // Set source first
        audio.src = url;

        // Mobile browsers require explicit user interaction
        audio.play().then(() => {
          console.log('â–¶ï¸ Playing audio...');
          audio.onended = () => {
            console.log('âœ… Audio finished');
            resolve();
          };
        }).catch((err) => {
          console.error('âŒ Audio play failed:', err);
          reject(err);
        });

        audio.onerror = (e) => {
          console.error('âŒ Audio load error:', e);
          reject(new Error('Audio load failed'));
        };
      });
    }

    /* --- STORAGE --- */
    getStorageKey() {
      // Generate key based on current file path
      if (!STATE.currentPath) return CONFIG.storageKey;
      // Replace / with _ to avoid key issues
      const pathKey = STATE.currentPath.replace(/\//g, '_').replace(/\.md$/, '');
      return `${CONFIG.storageKey}_${pathKey}`;
    }

    loadStatsForFile(path) {
      // Load stats for specific file
      const oldPath = STATE.currentPath;
      STATE.currentPath = path;
      const key = this.getStorageKey();
      const stored = localStorage.getItem(key);

      if (stored) {
        const parsed = JSON.parse(stored);
        STATE.stats = parsed.stats || {};
      } else {
        STATE.stats = {};
      }

      // Restore old path
      STATE.currentPath = oldPath;
    }

    loadState() {
      const globalKey = CONFIG.storageKey;
      const stored = localStorage.getItem(globalKey);
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          // Check version compatibility
          if (parsed.version !== CONFIG.version) {
            console.log('Data version mismatch, clearing old data');
            localStorage.removeItem(globalKey);
            return;
          }
          STATE.currentPath = parsed.currentPath || null;
          STATE.mode = parsed.mode || 'input';
          // Load stats for current file
          if (STATE.currentPath) {
            this.loadStatsForFile(STATE.currentPath);
          }
        } catch (e) {
          console.error('Failed to parse stored data, clearing:', e);
          localStorage.removeItem(globalKey);
        }
      }
    }

    saveState() {
      // Save global state (current path, mode)
      const globalData = {
        currentPath: STATE.currentPath,
        mode: STATE.mode,
        version: CONFIG.version
      };
      localStorage.setItem(CONFIG.storageKey, JSON.stringify(globalData));

      // Save file-specific stats
      if (STATE.currentPath) {
        const key = this.getStorageKey();
        const fileData = {
          stats: STATE.stats,
          version: CONFIG.version
        };
        localStorage.setItem(key, JSON.stringify(fileData));
      }
      this.updateStatsUI();
    }

    resetData() {
      if (confirm('ç¡®å®šé‡ç½®ï¼Ÿ')) {
        // Clear current file stats
        if (STATE.currentPath) {
          const key = this.getStorageKey();
          localStorage.removeItem(key);
        }
        // Clear global state
        localStorage.removeItem(CONFIG.storageKey);
        location.reload();
      }
    }

    /* --- FILE SELECTION --- */
    toggleFiles(forceOpen = false) {
      console.log('toggleFiles called, forceOpen:', forceOpen, 'filePanel:', this.ui.filePanel);

      const isOpening = forceOpen || !this.ui.filePanel.classList.contains('open');

      if (forceOpen) {
        this.ui.filePanel.classList.add('open');
        // Close stats panel if open
        this.ui.statsPanel.classList.remove('open');
      } else {
        this.ui.filePanel.classList.toggle('open');
      }

      console.log('toggleFiles - filePanel classes:', this.ui.filePanel.classList.toString());

      // If panel is being opened and is empty, load the file list
      if (isOpening) {
        // Check if the file list is empty (only has loading message)
        const currentContent = this.ui.fileListContainer.innerHTML;
        if (!currentContent || currentContent.includes('åŠ è½½ä¸­') || currentContent.includes('åŠ è½½æ–‡ä»¶å¤¹')) {
          console.log('File panel opened but empty, loading root folders...');
          this.loadRootFolders();
        }
      }
    }

    async loadRootFolders(forceRefresh = false) {
      try {
        console.log('ğŸ“‚ Loading root folders, fileListContainer:', this.ui.fileListContainer);
        console.log('filePanel element:', this.ui.filePanel);
        console.log('filePanel classes before:', this.ui.filePanel.classList.toString());
        console.log('filePanel computed style.display:', window.getComputedStyle(this.ui.filePanel).display);
        console.log('filePanel computed style.visibility:', window.getComputedStyle(this.ui.filePanel).visibility);

        this.ui.fileListContainer.innerHTML = `
          <div style="padding: 1rem; text-align: center; color: var(--secondary);">
            <div class="spinner" style="margin: 0 auto 1rem;"></div>
            åŠ è½½æ–‡ä»¶å¤¹...
          </div>
        `;
        console.log('innerHTML set, should show loading...');

        const contents = await GitHubApi.fetchContents('', forceRefresh);
        console.log('loadRootFolders - contents type:', typeof contents, 'isArray:', Array.isArray(contents));
        console.log('loadRootFolders - contents:', contents);

        const folders = GitHubApi.filterFolders(contents);
        const files = GitHubApi.filterMdFiles(contents);

        // Render current file info if exists
        let html = '';
        if (STATE.currentPath) {
          html += `
            <div class="current-file-info">
              <span>ğŸ“„</span>
              <span>å½“å‰æ–‡ä»¶: <strong>${STATE.currentPath}</strong></span>
            </div>
          `;
        }

        // Render breadcrumb
        html += `
          <div class="breadcrumb">
            <span class="breadcrumb-item">ğŸ“ English/Word</span>
          </div>
        `;

        // Render folders
        if (folders.length > 0) {
          folders.forEach(folder => {
            html += `
              <div class="folder-item" onclick="app.loadFolder('${folder.path}')">
                <span class="folder-item-icon">ğŸ“</span>
                <span class="folder-item-name">${folder.name}</span>
              </div>
            `;
          });
        }

        // Render files
        if (files.length > 0) {
          files.forEach(file => {
            // Compare relative paths since STATE.currentPath is now relative
            const relativePath = file.path.startsWith('english/word/') ? file.path.substring('english/word/'.length) : file.path;
            const isActive = relativePath === STATE.currentPath;
            html += `
              <div class="file-item ${isActive ? 'active' : ''}" onclick="app.selectFile('${file.path}', '${file.name}')">
                <span class="file-item-icon">ğŸ“„</span>
                <span class="file-item-name">${file.name}</span>
              </div>
            `;
          });
        }

        this.ui.fileListContainer.innerHTML = html;
      } catch (e) {
        console.error('åŠ è½½æ–‡ä»¶å¤¹å¤±è´¥:', e);
        this.ui.fileListContainer.innerHTML = `
          <div style="padding: 1rem; text-align: center; color: var(--danger);">
            <p>åŠ è½½å¤±è´¥: ${e.message}</p>
            <button class="btn-primary" onclick="app.loadRootFolders()" style="margin-top: 1rem;">é‡è¯•</button>
          </div>
        `;
      }
    }

    async loadFolder(path, forceRefresh = false) {
      try {
        this.ui.fileListContainer.innerHTML = `
          <div style="padding: 1rem; text-align: center; color: var(--secondary);">
            <div class="spinner" style="margin: 0 auto 1rem;"></div>
            åŠ è½½ä¸­...
          </div>
        `;

        // Handle full paths from GitHub API (e.g., "english/word/core" -> "core")
        const relativePath = path.startsWith('english/word/') ? path.substring('english/word/'.length) : path;
        const {folders, files} = await GitHubApi.fetchFolderContents(relativePath, forceRefresh);

        // Build breadcrumb
        const pathParts = path.split('/');
        let breadcrumbHtml = `
          <div class="breadcrumb">
            <span class="breadcrumb-item" onclick="app.loadRootFolders()">ğŸ“ English/Word</span>
        `;

        let currentPath = '';
        pathParts.forEach((part, idx) => {
          currentPath += (idx > 0 ? '/' : '') + part;
          breadcrumbHtml += `
            <span class="breadcrumb-separator">â€º</span>
            <span class="breadcrumb-item" onclick="app.loadFolder('${currentPath}')">${part}</span>
          `;
        });
        breadcrumbHtml += '</div>';

        let html = breadcrumbHtml;

        // Render folders
        if (folders.length > 0) {
          folders.forEach(folder => {
            html += `
              <div class="folder-item" onclick="app.loadFolder('${folder.path}')">
                <span class="folder-item-icon">ğŸ“</span>
                <span class="folder-item-name">${folder.name}</span>
              </div>
            `;
          });
        }

        // Render files
        if (files.length > 0) {
          files.forEach(file => {
            // Compare relative paths since STATE.currentPath is now relative
            const relativePath = file.path.startsWith('english/word/') ? file.path.substring('english/word/'.length) : file.path;
            const isActive = relativePath === STATE.currentPath;
            html += `
              <div class="file-item ${isActive ? 'active' : ''}" onclick="app.selectFile('${file.path}', '${file.name}')">
                <span class="file-item-icon">ğŸ“„</span>
                <span class="file-item-name">${file.name}</span>
              </div>
            `;
          });
        }

        if (folders.length === 0 && files.length === 0) {
          html += `
            <div style="padding: 2rem; text-align: center; color: var(--secondary);">
              æ­¤æ–‡ä»¶å¤¹ä¸ºç©º
            </div>
          `;
        }

        this.ui.fileListContainer.innerHTML = html;
      } catch (e) {
        console.error('åŠ è½½æ–‡ä»¶å¤¹å¤±è´¥:', e);
        this.ui.fileListContainer.innerHTML = `
          <div style="padding: 1rem; text-align: center; color: var(--danger);">
            <p>åŠ è½½å¤±è´¥: ${e.message}</p>
            <button class="btn-primary" onclick="app.loadRootFolders()" style="margin-top: 1rem;">è¿”å›æ ¹ç›®å½•</button>
          </div>
        `;
      }
    }

    selectFile(path, name) {
      if (path === STATE.currentPath) {
        // Already on this file, close panel
        this.toggleFiles();
        return;
      }

      // Show confirmation dialog
      const hasStarted = STATE.cards.length > 0 && STATE.currentIndex > 0;
      let message = `ç¡®å®šè¦åˆ‡æ¢åˆ°æ–‡ä»¶ <span class="highlight">${name}</span> å—ï¼Ÿ`;
      if (hasStarted) {
        message += `<br><br>å½“å‰æ–‡ä»¶çš„å­¦ä¹ è¿›åº¦å°†è¢«ä¿å­˜ã€‚`;
      }

      this.confirmDialog.show(message, () => this.confirmSwitchFile(path));
    }

    async confirmSwitchFile(path) {
      try {
        console.log('ğŸ“ confirmSwitchFile called with path:', path);

        // Close file panel immediately
        this.ui.filePanel.classList.remove('open');

        // Save current progress before switching
        if (STATE.currentPath && STATE.cards.length > 0) {
          this.saveState();
        }

        // Reset state and load new file
        STATE.cards = [];
        STATE.currentIndex = 0;
        console.log('ğŸ”„ About to call loadFile with path:', path);
        await this.loadFile(path);

        // Update current file info in file panel (without full reload)
        const fileInfo = document.querySelector('.current-file-info');
        if (fileInfo) {
          fileInfo.innerHTML = `
            <span>ğŸ“„</span>
            <span>å½“å‰æ–‡ä»¶: <strong>${STATE.currentPath}</strong></span>
          `;
        }
      } catch (e) {
        console.error('åˆ‡æ¢æ–‡ä»¶å¤±è´¥:', e);
        this.showToast('åˆ‡æ¢æ–‡ä»¶å¤±è´¥: ' + e.message);
        // Show file panel again on error
        this.ui.filePanel.classList.add('open');
      }
    }

    async refreshFileList() {
      try {
        // Clear all cache
        GitHubApi.clearCache();

        // Reload current folder
        const currentPath = this.getCurrentFolderPath();
        if (currentPath === null) {
          await this.loadRootFolders(true);
        } else {
          await this.loadFolder(currentPath, true);
        }

        this.showToast('âœ… åˆ—è¡¨å·²åˆ·æ–°');
      } catch (e) {
        console.error('åˆ·æ–°åˆ—è¡¨å¤±è´¥:', e);
        this.showToast('âŒ åˆ·æ–°å¤±è´¥: ' + e.message);
      }
    }

    getCurrentFolderPath() {
      // Determine current folder path from STATE.currentPath
      if (!STATE.currentPath) return null;

      const parts = STATE.currentPath.split('/');
      parts.pop(); // Remove filename
      return parts.join('/');
    }

    toggleStats() {
      this.ui.statsPanel.classList.toggle('open');
    }

    updateStatsUI() {
      let html = '';
      STATE.cards.forEach((c, idx) => {
        const s = STATE.stats[c.id];
        const isActive = idx === STATE.currentIndex;
        const err = s && s.errors ? `(${s.errors})` : '';
        let icon = 'ğŸ“';  // 'word' type
        if (c.type === 'phrase') icon = 'ğŸ”—';
        if (c.type === 'sentence') icon = 'ğŸ’¬';
        html += `
                        <div class="stat-row ${isActive ? 'active' : ''}" onclick="app.jumpTo(${idx})">
                            <span class="stat-word"><span class="tag-pill">${icon}</span>${c.word.substring(0, 18)}${c.word.length > 18 ? '...' : ''}</span>
                            <span class="stat-val" style="color:${s && s.errors ? 'var(--danger)' : 'inherit'}">${err}</span>
                        </div>
                    `;
      });
      this.ui.statsList.innerHTML = html;
      const active = this.ui.statsList.querySelector('.active');
      if (active) active.scrollIntoView({block: 'center'});
    }

    jumpTo(idx) {
      STATE.currentIndex = idx;
      this.render();
      this.toggleStats();
    }

    showToast(msg) {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.classList.add('show');
      setTimeout(() => t.classList.remove('show'), 2000);
    }

    confirmDialog = {
      confirmCallback: null,

      show(message, onConfirm) {
        console.log('ğŸ”² confirmDialog.show called');
        const overlay = app.ui.confirmDialog;
        const msgEl = app.ui.dialogMessage;
        const confirmBtn = app.ui.dialogConfirmBtn;

        // Set message and callback
        msgEl.innerHTML = message;
        this.confirmCallback = onConfirm;
        console.log('ğŸ”² Callback set:', typeof onConfirm);

        // Setup confirm button
        confirmBtn.onclick = () => {
          console.log('âœ… Confirm button clicked!');
          // Execute callback FIRST before hiding (hide() sets confirmCallback to null)
          if (this.confirmCallback) {
            console.log('ğŸ”² Executing callback...');
            const callback = this.confirmCallback;
            this.confirmCallback = null;
            callback();
          }
          this.hide();
        };

        // Show dialog
        overlay.classList.add('show');
      },

      hide() {
        app.ui.confirmDialog.classList.remove('show');
        this.confirmCallback = null;
      },

      cancel() {
        this.hide();
      }
    };
  }

  const app = new VocabApp();
</script>
</body>
</html>
