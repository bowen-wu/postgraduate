<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown Parser ÊµãËØïÂ∑•ÂÖ∑</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: calc(100vh - 40px);
        }
        .panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .panel-header {
            padding: 15px 20px;
            background: #4f46e5;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-content {
            flex: 1;
            overflow: auto;
            padding: 20px;
        }
        textarea {
            width: 100%;
            height: 100%;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 15px;
            font-family: "Monaco", "Menlo", "Courier New", monospace;
            font-size: 13px;
            resize: none;
            line-height: 1.6;
        }
        textarea:focus {
            outline: none;
            border-color: #4f46e5;
        }
        .output {
            font-family: "Monaco", "Menlo", "Courier New", monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .card-item {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .card-item:last-child {
            margin-bottom: 0;
        }
        .card-type {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            margin-right: 8px;
        }
        .type-word { background: #d1fae5; color: #10b981; }
        .type-phrase { background: #f3e8ff; color: #9333ea; }
        .type-sentence { background: #dbeafe; color: #2563eb; }
        .card-word {
            font-weight: bold;
            color: #1e293b;
            margin-bottom: 5px;
        }
        .card-detail {
            color: #64748b;
            font-size: 12px;
            margin-left: 10px;
        }
        .btn-run {
            padding: 8px 16px;
            background: white;
            color: #4f46e5;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-run:hover {
            background: #f1f5f9;
        }
        .stats {
            font-size: 12px;
            color: white;
            opacity: 0.9;
        }
        .error {
            color: #ef4444;
            background: #fee2e2;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <div class="panel-header">
                <span>ËæìÂÖ•ÊµãËØïÂÜÖÂÆπ (Markdown)</span>
                <button class="btn-run" onclick="runParser()">‚ñ∂ ÊâßË°åËß£Êûê</button>
            </div>
            <div class="panel-content">
                <textarea id="input" placeholder="Âú®Ê≠§ËæìÂÖ•ÊµãËØïÂÜÖÂÆπ...
‰æãÂ¶ÇÔºö
## acknowledge
- vt. ÊâøËÆ§ÔºõÂëäÁü•Êî∂ÊÇâÔºõÊÑüË∞¢
- === acknowledge([Àà…™pl…íd í…™z] (v. ÈÅìÊ≠â))
- I acknowledge your point."></textarea>
            </div>
        </div>
        <div class="panel">
            <div class="panel-header">
                <span>Ëß£ÊûêÁªìÊûú</span>
                <span class="stats" id="stats">Á≠âÂæÖÊâßË°å...</span>
            </div>
            <div class="panel-content">
                <div id="output" class="output"></div>
            </div>
        </div>
    </div>

    <script>
        /**
         * ADVANCED MARKDOWN PARSER (V5 - Sentence & Header Logic)
         */
        class MarkdownParser {
            constructor(text) {
                // 1. Cut off everything before the first ##
                const firstHeaderIdx = text.indexOf('##');
                if (firstHeaderIdx > -1) {
                    text = text.substring(firstHeaderIdx);
                }
                // 2. Merge multi-line list items into single lines
                text = this.mergeMultiLineItems(text);
                // 3. Expand synonym formats like "epidemic == pandemic [Èü≥Ê†á] Èáä‰πâ"
                text = this.expandSynonymFormats(text);
                this.lines = text.split('\n');
                this.cards = [];
                this.activeContextCard = null;
                this.inPhraseList = false;  // Track if we're under "- ËØçÁªÑ" list
                this.delayedSentenceCard = null;  // Store sentence card to push after its children
                this.lastWordCard = null;  // Track the last word/phrase card (before sentences)
            }

            /**
             * Merge multi-line list items
             * Lines that start with spaces/tabs (without -) and follow a list item
             * should be merged with the previous line
             */
            mergeMultiLineItems(text) {
                const lines = text.split('\n');
                const result = [];

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const trimmed = line.trim();

                    // If this line starts with '- ', it's a new list item
                    if (trimmed.startsWith('-')) {
                        result.push(line);
                    }
                    // If this line is indented but doesn't start with '-', and the previous line was a list item
                    else if (line.length > 0 && !trimmed.startsWith('-') && /^\s/.test(line)) {
                        // Check if previous line in result was a list item
                        if (result.length > 0 && result[result.length - 1].trim().startsWith('-')) {
                            // Merge with previous line
                            result[result.length - 1] = result[result.length - 1] + ' ' + trimmed;
                        } else {
                            // Not a continuation, keep as is
                            result.push(line);
                        }
                    }
                    // Headers or other lines
                    else {
                        result.push(line);
                    }
                }

                return result.join('\n');
            }

            /**
             * Expand special synonym formats
             * - "word1 == word2 [Èü≥Ê†á] Èáä‰πâ" -> "- word2 [Èü≥Ê†á] Èáä‰πâ\n    - == word1"
             * - "word1 == word2 ‰∏≠Êñá1, ‰∏≠Êñá2" -> "- word1 ‰∏≠Êñá1\n- word2 ‰∏≠Êñá2"
             */
            expandSynonymFormats(text) {
                const lines = text.split('\n');
                const result = [];

                for (let line of lines) {
                    const trimmed = line.trim();
                    if (!trimmed.startsWith('-')) {
                        result.push(line);
                        continue;
                    }

                    const content = trimmed.substring(1).trim();

                    // Pattern 1: "word1 == word2 Èáä‰πâ"
                    const matchWithIpa = content.match(/^([a-zA-Z-]+)\s+==\s+([a-zA-Z-]+)\s+(.+)$/);
                    if (matchWithIpa) {
                        // "epidemic == pandemic Èáä‰πâ"
                        // Extract: pandemic is the main word with definition
                        // epidemic is the synonym
                        const word1 = matchWithIpa[1];
                        const word2 = matchWithIpa[2];
                        const def = matchWithIpa[3].trim();

                        // Add main word with definition
                        result.push(`- ${word2} ${def}`);
                        // Add word1 as synonym (indented to make it a child item)
                        result.push(`    - == ${word1}`);
                        continue;
                    }

                    // Pattern 2: "word1 == word2 ‰∏≠Êñá1, ‰∏≠Êñá2"
                    const matchWithChinese = content.match(/^([a-zA-Z-]+)\s+==\s+([a-zA-Z-]+)\s+(.+)$/);
                    if (matchWithChinese) {
                        // "paycheck == salary Ëñ™ËµÑ, Ëñ™ÈÖ¨"
                        const word1 = matchWithChinese[1];
                        const word2 = matchWithChinese[2];
                        const chineseParts = matchWithChinese[3].split(/,\s*/);

                        // Add both words with their respective definitions
                        result.push(`- ${word1} ${chineseParts[0] || ''}`);
                        result.push(`- ${word2} ${chineseParts[1] || ''}`);
                        continue;
                    }

                    // No special format, keep original
                    result.push(line);
                }

                return result.join('\n');
            }

            parse() {
                try {
                    this.lines.forEach((line, index) => {
                        try {
                            const trimmed = line.trim();
                            if (!trimmed) return;

                            // IMPORTANT: Before creating a new card, check if we need to push delayed sentence card
                            // This ensures sentence cards appear AFTER their children
                            if (this.delayedSentenceCard) {
                                const leadingSpaces = line.match(/^(\s*)-/);
                                const indentLevel = leadingSpaces ? leadingSpaces[1].length : 0;

                                // Check if current line is NOT a child of the sentence
                                // Sentence children are: indented items + next line might be Chinese translation
                                const isChild = this.activeContextCard &&
                                    this.activeContextCard.type === 'sentence' &&
                                    indentLevel > 0;

                                if (!isChild) {
                                    // Current line is not a child of the sentence, push the delayed sentence card now
                                    this.cards.push(this.delayedSentenceCard);
                                    this.delayedSentenceCard = null;
                                } else if (this.activeContextCard && this.activeContextCard.type !== 'sentence') {
                                    // Special case: active context is NOT a sentence (e.g., word/phrase)
                                    // This means we're moving from a word/phrase to a new sentence
                                    // Push the delayed sentence card now
                                    if (this.delayedSentenceCard) {
                                        this.cards.push(this.delayedSentenceCard);
                                        this.delayedSentenceCard = null;
                                    }
                                }
                            }

                            // 1. Level 2 Headers (##)
                            if (trimmed.startsWith('##')) {
                                const content = trimmed.substring(2).trim();
                                // Filter: Must be a Word (Starts with Letter)
                                if (this.isValidWordHeader(content)) {
                                    const card = this.createCard(content, 'word');
                                    this.cards.push(card);
                                    this.lastWordCard = card;  // Track last word/phrase card
                                    this.activeContextCard = card;
                                } else {
                                    // Ignore header (Unit, Numbers, Words, ËØçÁªÑ)
                                    this.activeContextCard = null;
                                }
                                return;
                            }
                            // 2. List Items
                            if (trimmed.startsWith('-')) {
                                // Check indentation level (count leading spaces/tabs before the dash)
                                // IMPORTANT: Calculate this BEFORE using it!
                                const leadingSpaces = line.match(/^(\s*)-/);
                                const indentLevel = leadingSpaces ? leadingSpaces[1].length : 0;

                                const content = trimmed.substring(1).trim();

                                // Check for "- ËØçÁªÑ" marker (no indentation)
                                if (content === 'ËØçÁªÑ' && indentLevel === 0) {
                                    this.inPhraseList = true;
                                    this.activeContextCard = null;  // Clear context when entering phrase list
                                    return;
                                }

                                // Check if we're exiting phrase list (new header or different level-0 item)
                                if (this.inPhraseList && indentLevel === 0 && content !== 'ËØçÁªÑ') {
                                    this.inPhraseList = false;
                                }

                                // Ignore List Item
                                if (this.isIgnoredListItem(content)) return;

                                // Special handling: In phrase list
                                if (this.inPhraseList && indentLevel > 0) {
                                    // All indented items under "- ËØçÁªÑ" are phrases
                                    // Extract Chinese definition if present
                                    const chineseMatch = content.match(/[\u4e00-\u9fa5]+/);
                                    if (chineseMatch) {
                                        // Has Chinese definition: extract word and Chinese
                                        const chineseStart = content.indexOf(chineseMatch[0]);
                                        const beforeChinese = content.substring(0, chineseStart).trim();
                                        const chinesePart = content.substring(chineseStart).trim();

                                        // Clean the English part (remove IPA if any)
                                        let cleanEnglish = beforeChinese.replace(/(\[[^\]]+\]|\/[^\/]+\/)\s*/g, '').trim();

                                        // Create phrase card with definition
                                        const card = this.createCard(cleanEnglish, 'phrase');
                                        card.items = [{type: 'def', en: cleanEnglish, cn: chinesePart}];
                                        this.cards.push(card);
                                        this.lastWordCard = card;  // Track last word/phrase card
                                    } else {
                                        // No Chinese, just create phrase card
                                        const card = this.createCard(content, 'phrase');
                                        // Add default item
                                        if (card.items.length === 0) {
                                            card.items = [{type: 'def', en: card.word, cn: ''}];
                                        }
                                        this.cards.push(card);
                                        this.lastWordCard = card;  // Track last word/phrase card
                                    }
                                    return;
                                }

                                // LOGIC BRANCH: Floating Mode vs Context Mode
                                if (this.activeContextCard) {
                                    // If indented (nested item), always add to current context card
                                    if (indentLevel > 0) {
                                        this.processWithContext(content, this.activeContextCard, index);
                                    } else {
                                        // Same level - could be new word or continue context
                                        this.processWithContext(content, this.activeContextCard, index);
                                    }
                                } else {
                                    // Floating Mode (e.g., under ## 024, ## Âè•Âºè)
                                    // Check if it's a sentence FIRST, before checking if it's a word
                                    const startsWithUppercase = /^[A-Z]/.test(content);
                                    const hasPunctuation = /[,.!?]/.test(content);
                                    const looksLikeSentence = startsWithUppercase && (hasPunctuation || content.includes(',') || content.includes('.'));

                                    if (looksLikeSentence) {
                                        // It's a sentence, use processWithContext to handle it properly
                                        this.processWithContext(content, null, index);
                                    } else if (this.isWordStart(content) && !this.isDefinitionLine(content)) {
                                        // It's a word/phrase
                                        const newRoot = this.createCard(content, 'word');
                                        // Check if createCard returned a valid card (not empty word)
                                        if (newRoot.word && newRoot.word.length > 0) {
                                            this.cards.push(newRoot);
                                            this.lastWordCard = newRoot;  // Track last word/phrase card
                                            this.activeContextCard = newRoot;
                                        }
                                    }
                                }
                            }
                        } catch (lineError) {
                            console.warn(`Ëß£ÊûêÁ¨¨ ${index + 1} Ë°åÊó∂Âá∫Èîô:`, line, lineError);
                            // ÁªßÁª≠Ëß£Êûê‰∏ã‰∏ÄË°åÔºå‰∏ç‰∏≠Êñ≠Êï¥‰∏™ÊµÅÁ®ã
                        }
                    });

                    // After processing all lines, push any remaining delayed sentence card
                    if (this.delayedSentenceCard) {
                        this.cards.push(this.delayedSentenceCard);
                        this.delayedSentenceCard = null;
                    }

                    return this.cards;
                } catch (error) {
                    console.error('Ëß£ÊûêËøáÁ®ãÂá∫Èîô:', error);
                    throw new Error(`Ëß£ÊûêÂ§±Ë¥•: ${error.message}`);
                }
            }

            isValidWordHeader(text) {
                if (/^(Words|ËØçÁªÑ|Âè•Âºè)$/.test(text)) return false;
                return /^[a-zA-Z]/.test(text);
            }

            isIgnoredListItem(content) {
                if (/^\[.*?\]$/.test(content)) return true;
                if (/^(ËØçÁªÑ|Âè•Âºè|Sentences|Words)$/.test(content)) return true;
                return false;
            }

            isWordStart(content) {
                return /^[a-zA-Z]/.test(content);
            }

            // Check if content is just a definition (starts with pos.)
            isDefinitionLine(content) {
                return /^[a-z]+\.\s*/.test(content);
            }

            processWithContext(content, parent, index) {
                // Special handling: Pure IPA line (e.g., "- [Èü≥Ê†á]")
                // If the line only contains IPA (no word, no Chinese), update parent's IPA
                const ipaMatchSlash = content.match(/^\/.*\/$/);
                const ipaMatchBracket = content.match(/^\[.*\]$/);
                if ((ipaMatchSlash || ipaMatchBracket) && parent) {
                    // This is a pure IPA line, update parent's IPA
                    if (ipaMatchSlash && !parent.ipa) {
                        parent.ipa = ipaMatchSlash[0];
                    } else if (ipaMatchBracket && !parent.ipa) {
                        parent.ipa = ipaMatchBracket[0];
                    }
                    return; // Don't create a new card
                }

                // Special handling: Child of sentence card
                // Sentences only have word/phrase children, never nested sentences
                if (parent && parent.type === 'sentence') {
                    // Check if this content is a synonym/antonym (== or Opposite:)
                    if (/^===?\s+/.test(content)) {
                        // Add to lastWordCard's synonyms, not to the sentence
                        if (this.lastWordCard) {
                            const synonymContent = content.replace(/^===?\s+/, '').trim();
                            this.lastWordCard.synonyms = this.lastWordCard.synonyms || [];
                            this.lastWordCard.synonyms.push({word: synonymContent, def: ''});
                        }
                        return;
                    }

                    // Check if it's a pure definition (starts with pos. and has Chinese, no word)
                    // e.g., "n. Â±ÖÊ∞ëÔºõ‰ΩèÊà∑" or "vi.ÔºàÊ≠£ÂºèÊñá‰ª∂ÔºâÂà∞Êúü"
                    if (/^[a-z]+\.\s*/.test(content) && /[\u4e00-\u9fa5]/.test(content)) {
                        // This is a pure definition line, add to lastWordCard
                        if (this.lastWordCard) {
                            // Try to match with space first: "n. Â±ÖÊ∞ë"
                            let posMatch = content.match(/^([a-z]+\.)\s+(.+)$/);
                            if (!posMatch) {
                                // If no space, try without space: "vi.ÔºàÊ≠£ÂºèÊñá‰ª∂ÔºâÂà∞Êúü"
                                posMatch = content.match(/^([a-z]+\.)(.+)$/);
                            }
                            if (posMatch) {
                                this.lastWordCard.items.push({type: 'def', en: posMatch[1], cn: posMatch[2]});
                            }
                        }
                        return;
                    }

                    // Check if this content has Chinese
                    const hasChinese = /[\u4e00-\u9fa5]/.test(content);
                    if (!hasChinese) {
                        return;
                    }

                    // Check if it's a sentence pattern (e.g., "extend A to B Âª∂‰º∏Âà∞", "sth worries sb Êüê‰∫ãËÆ©Êüê‰∫∫ÊãÖÂøß")
                    // Pattern: has Chinese, no POS marker (n./v./adj.), not starting with an English word definition
                    const hasPosAtStart = /^[a-z]+\.\s*/.test(content);  // More precise: starts with "n. ", "v. ", etc.

                    // Also check if it contains a POS marker anywhere (e.g., "dweller n. Â±Ö‰ΩèËÄÖ")
                    const hasPosAnywhere = /\s[a-z]+\./.test(content);

                    // Note: Removed pattern checking logic as patterns field is not needed

                    // Has Chinese: Check if it has POS marker (e.g., "dweller n. Â±Ö‰ΩèËÄÖ")
                    const hasPosInContent = /^[a-zA-Z-]+\s+[a-z]+\./.test(content) ||
                        /^[a-zA-Z-]+\s+\[.*?\]\s*[a-z]+\./.test(content);

                    if (hasPosInContent) {
                        // Has POS marker: Create as WORD card (always word if has POS)
                        // IMPORTANT: Push delayed sentence card first (if exists)
                        // This ensures sentence appears before its extracted words
                        if (this.delayedSentenceCard) {
                            this.cards.push(this.delayedSentenceCard);
                            this.delayedSentenceCard = null;
                        }

                        const card = this.createCard(content, 'word');
                        this.cards.push(card);
                        this.lastWordCard = card;
                        this.activeContextCard = card;
                        return;
                    }

                    // No POS marker: Check if it's a phrase or word
                    // Remove IPA first
                    let textForCheck = content.replace(/(\[[^\]]+\]|\/[^\/]+\/)\s*/g, '').trim();

                    // Check if it's a phrase (contains space) or word
                    const isPhrase = /\s/.test(textForCheck);
                    const cardType = isPhrase ? 'phrase' : 'word';

                    // IMPORTANT: Push delayed sentence card first (if exists)
                    // This ensures sentence appears before its extracted words/phrases
                    if (this.delayedSentenceCard) {
                        this.cards.push(this.delayedSentenceCard);
                        this.delayedSentenceCard = null;
                    }

                    const card = this.createCard(content, cardType);
                    this.cards.push(card);
                    this.lastWordCard = card;
                    this.activeContextCard = card;
                    return;
                }

                // Type: Definition (n./v./...) with optional Chinese
                // Pattern: "vt. ÊâøËÆ§ÔºõÂëäÁü•Êî∂ÊÇâÔºõÊÑüË∞¢" or "n. Áü•ËØÜÔºõÁü•Êôì" or "vi.ÔºàÊ≠£ÂºèÊñá‰ª∂ÔºâÂà∞Êúü"
                // Note: Chinese parenthesis Ôºà may directly follow the POS without space
                if (/^[a-z]+\.\s*/.test(content)) {
                    // Try to match with space first: "vt. ÊâøËÆ§"
                    let posMatch = content.match(/^([a-z]+\.)\s+(.+)$/);
                    if (!posMatch) {
                        // If no space, try without space: "vi.ÔºàÊ≠£ÂºèÊñá‰ª∂ÔºâÂà∞Êúü"
                        posMatch = content.match(/^([a-z]+\.)(.+)$/);
                    }
                    if (posMatch) {
                        const pos = posMatch[1]; // "vt." or "vi."
                        const rest = posMatch[2]; // "ÊâøËÆ§ÔºõÂëäÁü•Êî∂ÊÇâÔºõÊÑüË∞¢" or "ÔºàÊ≠£ÂºèÊñá‰ª∂ÔºâÂà∞Êúü"

                        // Check if rest contains Chinese
                        const chineseMatch = rest.match(/[\u4e00-\u9fa5]+/);
                        if (chineseMatch) {
                            // Has Chinese: split POS and Chinese
                            parent.items.push({type: 'def', en: pos, cn: rest});
                        } else {
                            // No Chinese: keep as is
                            parent.items.push({type: 'def', en: content, cn: ''});
                        }
                    } else {
                        // No match, keep original
                        parent.items.push({type: 'def', en: content, cn: ''});
                    }
                    return;
                }
                // Type: Synonym (==) or Antonym (- Opposite:)
                if (/^===?\s+/.test(content)) {
                    const synonymContent = content.replace(/^===?\s+/, '').trim();

                    // Check if it's an antonym (Opposite: word)
                    const isAntonym = /^Opposite:\s*/i.test(synonymContent);

                    // Remove "Opposite:" prefix if exists
                    const antonymContent = isAntonym ?
                        synonymContent.replace(/^Opposite:\s*/i, '').trim() :
                        synonymContent;

                    // Handle multiple synonyms separated by == (e.g., "word1 == word2")
                    const synonymParts = antonymContent.split(/\s+==\s+/);

                    if (parent) {
                        // Choose array based on whether it's antonym or synonym
                        const targetArray = isAntonym ? 'antonyms' : 'synonyms';
                        if (!parent[targetArray]) parent[targetArray] = [];

                        synonymParts.forEach(part => {
                            const partTrimmed = part.trim();
                            if (!partTrimmed) return;

                            // Pattern: word1 == word2 [Èü≥Ê†á] Èáä‰πâ
                            // The IPA and definition belong to the first word, so we need to extract it
                            const matchWithIpa = partTrimmed.match(/^([a-zA-Z-]+)\s+([a-zA-Z-]+)\s+\[([^\]]+)\](.+)$/);
                            if (matchWithIpa) {
                                // "epidemic == pandemic [Èü≥Ê†á] Èáä‰πâ"
                                // The first word (epidemic) has IPA and definition
                                const word = matchWithIpa[1];
                                const ipa = `[${matchWithIpa[3]}]`;
                                const def = matchWithIpa[4].trim();
                                parent[targetArray].push({
                                    word: word,
                                    def: def,
                                    ipa: ipa,
                                    isAntonym: isAntonym  // Mark if it's an antonym
                                });
                            } else {
                                // Check if it's "word1 == word2 ‰∏≠Êñá1, ‰∏≠Êñá2" format
                                const matchWithChinese = partTrimmed.match(/^([a-zA-Z-]+)\s+([a-zA-Z-]+)\s+(.+)$/);
                                if (matchWithChinese) {
                                    // "paycheck == salary Ëñ™ËµÑ, Ëñ™ÈÖ¨"
                                    const words = [matchWithChinese[1], matchWithChinese[2]];
                                    const chineseParts = matchWithChinese[3].split(/,\s*/);

                                    words.forEach((w, idx) => {
                                        parent[targetArray].push({
                                            word: w,
                                            def: chineseParts[idx] || '',
                                            isAntonym: isAntonym
                                        });
                                    });
                                } else {
                                    // Remove IPA/phonetic symbols before matching: "criticize [ipa] vt. ÊâπËØÑ" -> "criticize vt. ÊâπËØÑ"
                                    const withoutIpa = partTrimmed.replace(/(\[[^\]]+\]|\/[^\/]+\/)\s*/g, '').trim();

                                    // Pattern 1: word pos. definition (e.g., "guarantee v. ÊãÖ‰øù")
                                    const synonymWithPos = withoutIpa.match(/^([a-zA-Z-]+)\s+([a-z]+\.\s+.+)$/);
                                    // Pattern 2: phrase/word definition (e.g., "making a promise" or "word definition")
                                    const synonymWithoutPos = withoutIpa.match(/^([a-zA-Z-\s]+?)\s+(.+)$/);

                                    if (synonymWithPos) {
                                        // Has POS: "guarantee v. ÊãÖ‰øù"
                                        // Check if the definition part contains POS pattern (e.g., "vt. ÊâπËØÑ")
                                        const defPart = synonymWithPos[2];
                                        const posInDef = defPart.match(/^([a-z]+\.\s*)(.+)$/);
                                        if (posInDef) {
                                            // Split POS and Chinese: "vt. ÊâπËØÑ" -> "vt.", "ÊâπËØÑ"
                                            parent[targetArray].push({
                                                word: synonymWithPos[1],
                                                def: posInDef[2].trim(),
                                                pos: posInDef[1].trim(),
                                                isAntonym: isAntonym
                                            });
                                        } else {
                                            parent[targetArray].push({
                                                word: synonymWithPos[1],
                                                def: synonymWithPos[2],
                                                isAntonym: isAntonym
                                            });
                                        }
                                    } else if (synonymWithoutPos) {
                                        // No POS: "making a promise"
                                        // Check if definition contains POS
                                        const defPart = synonymWithoutPos[2].trim();
                                        const posInDef = defPart.match(/^([a-z]+\.\s*)(.+)$/);
                                        if (posInDef) {
                                            parent[targetArray].push({
                                                word: synonymWithoutPos[1].trim(),
                                                def: posInDef[2].trim(),
                                                pos: posInDef[1].trim(),
                                                isAntonym: isAntonym
                                            });
                                        } else {
                                            parent[targetArray].push({
                                                word: synonymWithoutPos[1].trim(),
                                                def: synonymWithoutPos[2].trim(),
                                                isAntonym: isAntonym
                                            });
                                        }
                                    } else {
                                        // Just a word or phrase without definition
                                        parent[targetArray].push({
                                            word: partTrimmed,
                                            def: '',
                                            isAntonym: isAntonym
                                        });
                                    }
                                }
                            }
                        });
                    }
                    // Don't create a separate card, just add to parent
                    return;
                }
                // Type: Sentence (Deep Parsing)
                // Check if content looks like a sentence:
                // - Starts with uppercase letter (with optional bold markers, <ins> tag, or quotes), OR
                // - Starts with ... (continuation), OR
                // - Starts with articles (the, a, an) or common sentence starters, OR
                // - Starts with common abbreviations (sb., sth., someone, something), OR
                // - Contains sentence punctuation (comma, period, question mark, exclamation mark)
                const startsWithUppercase = /^(\*{0,2})?(<ins>)?["']?([A-Z])/.test(content);
                const startsWithEllipsis = /^\.\.\./.test(content);
                const startsWithArticle = /^(\*{0,2})?(<ins>)?(the|a|an|this|that|these|those|there|here)\b/i.test(content);
                // Add common abbreviations: sb., sth., someone, something, etc.
                const startsWithAbbrev = /^(\*{0,2})?(<ins>)?(sb\.|sth\.|someone|something|there|here)\b/i.test(content);
                const hasBoldOrItalic = /\*\*/.test(content) || /\*/.test(content) || /<ins>/.test(content);

                // NEW: Use punctuation to distinguish phrases vs sentences (no length threshold)
                const hasComma = content.includes(',');
                const hasPeriod = content.includes('.');
                const hasQuestion = content.includes('?');
                const hasExclamation = content.includes('!');
                const hasSentencePunctuation = hasComma || hasPeriod || hasQuestion || hasExclamation;

                const startsWithSentenceStart = startsWithUppercase || startsWithEllipsis || startsWithArticle || startsWithAbbrev;
                const looksLikeSentence = startsWithSentenceStart && (hasSentencePunctuation || hasBoldOrItalic);

                if (looksLikeSentence) {
                    const extracted = this.parseSentence(content);
                    // 1. Add extracted embedded words/phrases first
                    if (extracted.extracted && extracted.extracted.length > 0) {
                        extracted.extracted.forEach(item => {
                            // Determine card type based on extracted item type
                            const cardType = item.type || 'word';  // 'word' or 'phrase'

                            // Check if card already exists for this word (matching type)
                            let card = this.cards.find(c => c.word === item.word && c.type === cardType);
                            if (!card) {
                                // Create card with appropriate type
                                card = this.createCard(item.word, cardType);
                                // If item has IPA, add it to the card
                                if (item.ipa) {
                                    card.ipa = `[${item.ipa}]`;
                                }
                                this.cards.push(card);
                                this.lastWordCard = card;  // Track last word/phrase card
                            } else {
                                // If card exists but doesn't have IPA and item has IPA, add it
                                if (item.ipa && !card.ipa) {
                                    card.ipa = `[${item.ipa}]`;
                                }
                                this.lastWordCard = card;  // Update last word card
                            }
                            // Add definition if it doesn't exist
                            // Parse the definition to separate POS from Chinese meaning
                            let defEn = item.word;
                            let defCn = item.def || '';

                            // Check if def contains POS pattern (e.g., "vt. ÊâøËÆ§")
                            if (defCn) {
                                const posInDef = defCn.match(/^([a-z]+\.\s*)(.+)$/);
                                if (posInDef) {
                                    // Has POS: "vt. ÊâøËÆ§" -> en="vt.", cn="ÊâøËÆ§"
                                    defEn = posInDef[1].trim();
                                    defCn = posInDef[2].trim();
                                }
                            }

                            const defExists = card.items.some(i => i.en === defEn);
                            if (!defExists) {
                                card.items.push({type: 'def', en: defEn, cn: defCn});
                            }
                        });
                    }
                    // 2. Add Clean Sentence Card
                    // Extract first few words as title
                    const titleWords = extracted.clean.split(/\s+/).slice(0, 6).join(' ');
                    const title = titleWords.length > 40 ? titleWords.substring(0, 40) + '...' : titleWords;
                    const sentCard = {
                        id: `sent_${this.cards.length}`,
                        word: title,
                        fullText: extracted.clean,
                        type: 'sentence',
                        items: [{type: 'sentence', en: extracted.clean, cn: ''}]
                    };

                    // Check if there's Chinese translation for the sentence (next line)
                    const nextLineIdx = index + 1;
                    if (nextLineIdx < this.lines.length) {
                        const nextLine = this.lines[nextLineIdx].trim();
                        // Check if it's a Chinese translation (starts with - and contains Chinese, no English letters)
                        if (nextLine.startsWith('-') && /[\u4e00-\u9fa5]/.test(nextLine)) {
                            const cnText = nextLine.substring(1).trim();
                            sentCard.items[0].cn = cnText;
                            // Mark this line as processed to avoid creating a separate card
                            // We'll skip it in the main loop by setting a flag
                            this.lines[nextLineIdx] = ''; // Clear the line
                        }
                    }

                    // IMPORTANT: Don't push sentence card immediately!
                    // Store it in delayedSentenceCard, so it will be pushed AFTER all its children
                    this.delayedSentenceCard = sentCard;

                    // Switch to sentence as active context, so subsequent indented items belong to it
                    this.activeContextCard = sentCard;
                    return;
                }
                // Type: Word/Phrase with POS and Chinese Translation (e.g., "knowledgeable adj. Áü•ËØÜÊ∏äÂçöÁöÑ")
                // Pattern: word pos. ‰∏≠Êñá or word ‰∏≠Êñá
                const chineseMatch = content.match(/[\u4e00-\u9fa5]+/);
                if (chineseMatch) {
                    const chineseStart = content.indexOf(chineseMatch[0]);
                    const beforeChinese = content.substring(0, chineseStart).trim();
                    const chinesePart = content.substring(chineseStart).trim();

                    if (content.includes('dweller')) {
                        console.log(`üîç [DEBUG] Processing dweller line:`);
                        console.log(`  content: "${content}"`);
                        console.log(`  beforeChinese: "${beforeChinese}"`);
                        console.log(`  chinesePart: "${chinesePart}"`);
                    }

                    if (beforeChinese) {
                        // Remove ** markers from the English part before processing
                        let cleanBeforeChinese = beforeChinese.replace(/\*\*/g, '');

                        // Remove IPA/phonetic symbols BEFORE checking POS
                        // e.g., "silly [Ààs…™li] adj." -> "silly adj."
                        cleanBeforeChinese = cleanBeforeChinese.replace(/(\[[^\]]+\]|\/[^\/]+\/)\s*/g, '').trim();

                        if (content.includes('dweller')) {
                            console.log(`  cleanBeforeChinese: "${cleanBeforeChinese}"`);
                        }

                        // Check if there's a POS (part of speech) pattern: word pos.
                        // POS patterns: adj., adv., n., v., vt., vi., prep., conj., etc.
                        // The POS can be followed by Chinese or nothing (e.g., "surpassed adj. ÂèØË∂ÖËøáÁöÑ")
                        // Exclude common placeholders: sb., sth., etc.
                        const posMatch = cleanBeforeChinese.match(/\s+(?!sb\.|sth\.)([a-z]+\.)/);

                        if (content.includes('dweller')) {
                            console.log(`  posMatch:`, posMatch);
                        }
                        let wordPart, posPart;

                        if (posMatch) {
                            // Has POS: "silly adj."
                            posPart = posMatch[1]; // "adj."
                            wordPart = cleanBeforeChinese.substring(0, posMatch.index).trim(); // "silly"
                        } else {
                            // No POS: "housing crisis" or "Federal Bureau of Investigation"
                            wordPart = cleanBeforeChinese;
                            posPart = '';
                        }

                        if (wordPart) {
                            // Check if we should add to parent or create new card
                            // If parent exists and matches the word, add to parent
                            if (parent && parent.word === wordPart) {
                                // Add definition to existing parent card
                                // If there's a POS, only show the POS (not the word again)
                                const defEn = posPart || wordPart;
                                parent.items.push({type: 'def', en: defEn, cn: chinesePart});
                                return;
                            }

                            // Determine card type: 'phrase' if multiple words, 'word' if single word
                            const isPhrase = /\s/.test(wordPart);
                            const cardType = isPhrase ? 'phrase' : 'word';

                            // Create or find card for this word/phrase
                            let card = this.cards.find(c => c.word === wordPart && c.type === cardType);
                            if (!card) {
                                card = this.createCard(wordPart, cardType);
                                // For phrases without initial definition, add default item
                                // This will be replaced/updated with the actual definition below
                                if (cardType === 'phrase' && card.items.length === 0) {
                                    card.items = [{type: 'def', en: wordPart, cn: ''}];
                                }
                                this.cards.push(card);
                                this.lastWordCard = card;  // Track last word/phrase card
                            }

                            // Add definition with POS and Chinese
                            // en: If there's a POS, only show the POS (e.g., "adj."), otherwise show the word
                            // cn: Chinese translation
                            const defEn = posPart || wordPart;

                            // Check if we need to add/update the definition
                            // Case 1: Card has an item from createCard with the same def - don't duplicate
                            // Case 2: Card has empty/default item - update it
                            // Case 3: Card has different items - add new definition
                            const hasMatchingDef = card.items.length > 0 &&
                                card.items[0].en === defEn &&
                                card.items[0].cn === chinesePart;

                            if (hasMatchingDef) {
                                // Already has the correct definition from createCard, don't duplicate
                                console.log(`  -> Card already has correct definition, skipping duplicate`);
                            } else if (card.items.length === 1 && card.items[0].cn === '' && card.items[0].en === wordPart) {
                                // Update the default item
                                card.items[0] = {type: 'def', en: defEn, cn: chinesePart};
                            } else if (card.items.length === 0) {
                                // No items yet, add the first one
                                card.items.push({type: 'def', en: defEn, cn: chinesePart});
                            } else {
                                // Add new definition (different from existing ones)
                                card.items.push({type: 'def', en: defEn, cn: chinesePart});
                            }

                            // Update active context
                            this.activeContextCard = card;
                            return;
                        }
                    }
                }

                // Type: Word/Phrase with Chinese Translation (e.g., "housing crisis ‰ΩèÊàøÂç±Êú∫")
                // This is a fallback for cases without POS

                // Type: Word (Default fallback)
                // Determine if it's a phrase (multiple words) or word (single word)
                // IMPORTANT: Remove IPA/phonetic symbols BEFORE checking if it's a phrase!
                // e.g., "deter [d…™Ààt…úÀêr]" should be treated as a single word, not a phrase
                const fallbackIpaMatchSlash = content.match(/\/.*?\//);
                const fallbackIpaMatchBracket = content.match(/\[[^\]]+\]/);
                let textWithoutIpa = content;
                if (fallbackIpaMatchSlash) {
                    textWithoutIpa = content.replace(fallbackIpaMatchSlash[0], '').trim();
                } else if (fallbackIpaMatchBracket) {
                    textWithoutIpa = content.replace(fallbackIpaMatchBracket[0], '').trim();
                }

                // Check if this is a pure IPA line (no actual word content)
                // If so, skip creating a card
                if (!textWithoutIpa || textWithoutIpa.length === 0) {
                    // This is just an IPA line, skip it
                    return;
                }

                // Check if there's a POS pattern (e.g., "surpassed adj.")
                // This helps distinguish "surpassed adj." (word) from "housing crisis" (phrase)
                // Exclude common placeholders: sb., sth., etc.
                const posMatch = textWithoutIpa.match(/\s+(?!sb\.|sth\.)([a-z]+\.)/);
                let wordPart = textWithoutIpa;
                if (posMatch) {
                    // Has POS: extract word part (before POS)
                    wordPart = textWithoutIpa.substring(0, posMatch.index).trim();
                }

                // Check if it's a phrase (multiple words) or single word
                const isPhrase = /\s/.test(wordPart);
                const cardType = isPhrase ? 'phrase' : 'word';

                if (content.includes('dweller')) {
                    console.log(`üîç [DEBUG] Fallback case for dweller:`);
                    console.log(`  content: "${content}"`);
                    console.log(`  textWithoutIpa: "${textWithoutIpa}"`);
                    console.log(`  wordPart: "${wordPart}"`);
                    console.log(`  isPhrase: ${isPhrase}`);
                    console.log(`  cardType: ${cardType}`);
                }

                const card = this.createCard(content, cardType);
                this.cards.push(card);
                this.lastWordCard = card;  // Track last word/phrase card
                this.activeContextCard = card;
            }

            /**
             * Sentence Deep Parsing
             * Rules:
             * a. *xxx* -> Unknown word (extract as card)
             * b. **xxx** -> Known word (remove bold markers only)
             * c. <ins>xxx</ins> -> Phrase (extract as card)
             * d. word(def) -> Unknown word (extract as card)
             * e. Clean result -> Sentence Card
             */
            parseSentence(raw) {
                const extracted = [];
                let clean = raw;

                // 0. FIRST: Remove *word([Èü≥Ê†á])* patterns with ONLY IPA (no definition)
                // e.g., "*dentistry([Ààd…õnt…™stri])*" -> "dentistry" (no card created)
                // e.g., "*paradise([Ààp√¶r…ôda…™s])*" -> "paradise" (no card created)
                // This must come BEFORE the pattern that captures [IPA] + definition
                const ipaOnlyWords = []; // Track words with only IPA (should not be extracted)
                clean = clean.replace(/\*([a-zA-Z'-]+)\(\[([^\]]+)\]\)\*/g, (match, p1, p2) => {
                    // Strip possessive 's from word (e.g., "suspect's" -> "suspect")
                    let word = p1.trim();
                    if (word.endsWith('\'s') || word.endsWith('\'S')) {
                        word = word.slice(0, -2);
                    }
                    // Remember this word so we don't extract it later as *word*
                    ipaOnlyWords.push(word);
                    return word; // Keep just the word, no card created
                });

                // 0.1. NEXT: Extract *word([Èü≥Ê†á] Èáä‰πâ)* patterns with IPA AND definition
                // e.g., "*suspect's([s…ôÀàspekt] n. Â´åÁñëÁäØ)*" -> creates card with IPA and definition
                // This handles nested patterns like <ins>*word(def)* extra text</ins>
                clean = clean.replace(/\*([a-zA-Z'-]+)\(\[([^\]]+)\]\s+([^\)]+?)\)\*/g, (match, p1, p2, p3) => {
                    // Strip possessive 's from word (e.g., "suspect's" -> "suspect")
                    let word = p1.trim();
                    if (word.endsWith('\'s') || word.endsWith('\'S')) {
                        word = word.slice(0, -2);
                    }

                    // Extract word, IPA (Èü≥Ê†á), and definition
                    extracted.push({
                        word: word,
                        fullMatch: match,
                        type: 'word',
                        ipa: p2.trim(),
                        def: p3.trim()
                    });
                    return word; // Keep just the word
                });

                // 0.2. THEN: Extract *word(ËØçÊÄß ‰∏≠Êñá)* patterns without IPA (e.g., "*nervous(adj. ÁÑ¶ËôëÁöÑ)*")
                // ONLY extract if the definition contains a POS marker (adj., n., v., etc.)
                // If it's just Chinese without POS, don't extract (e.g., "*rides(Ê∏∏‰πêÂõ≠ÁöÑÊ∏∏‰πêËÆæÊñΩ)*" should be ignored)
                clean = clean.replace(/\*([a-zA-Z'-]+)\(([^)]+)\)\*/g, (match, p1, p2) => {
                    // Strip possessive 's from word (e.g., "suspect's" -> "suspect")
                    let word = p1.trim();
                    if (word.endsWith('\'s') || word.endsWith('\'S')) {
                        word = word.slice(0, -2);
                    }

                    const def = p2.trim();

                    // Check if definition contains a POS marker (e.g., "adj.", "n.", "vt.")
                    const hasPOS = /^[a-z]+\.\s*/.test(def);

                    if (hasPOS) {
                        // Only extract if there's a POS marker
                        extracted.push({
                            word: word,
                            fullMatch: match,
                            type: 'word',
                            def: def
                        });
                    }
                    // If no POS marker, just return the word without creating a card
                    return word; // Keep just the word
                });

                // 0.5. Extract word([Èü≥Ê†á] (Èáä‰πâ)) patterns without asterisks
                // This handles patterns like "monetary([Ààm…ëÀên…™teri] (adj. ÈáëÈí±ÁöÑ))" or "predators([p'red…ôt…ôz] (n. È£üËÇâÂä®Áâ©))"
                // Note: The definition part is wrapped in parentheses
                clean = clean.replace(/([a-zA-Z'-]+)\(\[([^\]]+)\](?:\s*)?\(([^)]+)\)/g, (match, p1, p2, p3) => {
                    // p1 = word, p2 = IPA, p3 = definition
                    // Strip possessive 's from word (e.g., "suspect's" -> "suspect")
                    let word = p1.trim();
                    if (word.endsWith('\'s') || word.endsWith('\'S')) {
                        word = word.slice(0, -2);
                    }

                    // Check if definition contains Chinese or POS pattern
                    const hasChinese = /[\u4e00-\u9fa5]/.test(p3);
                    const hasPOS = /[a-z]+\./.test(p3);

                    if (!hasChinese && !hasPOS) {
                        // Just IPA without meaningful definition, skip creating card
                        return word; // Keep just the word
                    }

                    // Check if it's already extracted (avoid duplicates)
                    const alreadyExtracted = extracted.some(e => e.word === word && e.fullMatch === match);
                    if (!alreadyExtracted) {
                        extracted.push({
                            word: word,
                            fullMatch: match,
                            type: 'word',
                            ipa: p2.trim(),
                            def: p3.trim()
                        });
                    }
                    return word; // Keep just the word
                });

                // 0.6. Remove word([Èü≥Ê†á]) patterns with only IPA (no asterisks)
                // e.g., "authorized(['…îŒ∏…ôÀåra…™zd])"
                clean = clean.replace(/([a-zA-Z'-]+)\(\[([^\]]+)\]\)/g, (match, p1, p2) => {
                    // Strip possessive 's from word (e.g., "suspect's" -> "suspect")
                    let word = p1.trim();
                    if (word.endsWith('\'S') || word.endsWith('\'s')) {
                        word = word.slice(0, -2);
                    }
                    return word; // Keep just the word, no card created
                });

                // 1. FIRST: Remove all bold markers **word** (known words)
                // ** represents the current word being studied, should be removed first
                // This ensures <ins>**phrase**</ins> is extracted correctly
                clean = clean.replace(/\*\*(.*?)\*\*/g, '$1');

                // 2. NEXT: Extract <ins>phrase</ins> or <ins>phrase(def)</ins> (ËØçÁªÑ)
                // After ** is removed, we can extract phrases cleanly
                // e.g., "<ins>Paralysis by analysis(Âõ†‰∏∫ËøáÂ∫¶ÂàÜÊûêËÄåÁò´Áó™)</ins>" -> creates phrase card
                // e.g., "<ins>shocking(adj. ÂèØÊÄïÁöÑ)</ins>" -> creates word card
                // e.g., "<ins>turned</ins>" -> DISCARD (single word without POS)
                clean = clean.replace(/<ins>(.*?)<\/ins>/g, (match, p1) => {
                    // First, remove any remaining *italic* markers from the phrase
                    let cleanContent = p1.replace(/\*/g, '').trim();

                    // Check if it contains definition in parentheses: phrase(def)
                    const phraseWithDef = cleanContent.match(/^(.+)\(([^)]+)\)$/);
                    if (phraseWithDef) {
                        // Has definition
                        let phrase = phraseWithDef[1].trim();
                        const def = phraseWithDef[2].trim();

                        // Check if definition has POS (part of speech)
                        // Note: POS may directly follow without space: "adj.ÂèØÊÄïÁöÑ"
                        const hasPOS = /^[a-z]+\.\s*/.test(def);

                        if (hasPOS) {
                            // <ins>shocking(adj. ÂèØÊÄïÁöÑ)</ins> ‚Üí ÂçïËØç
                            extracted.push({
                                word: phrase,
                                fullMatch: match,
                                type: 'word',
                                def: def
                            });
                        } else {
                            // <ins>Paralysis by analysis(Âõ†‰∏∫ËøáÂ∫¶ÂàÜÊûêËÄåÁò´Áó™)</ins> ‚Üí ËØçÁªÑ
                            extracted.push({
                                word: phrase,
                                fullMatch: match,
                                type: 'phrase',
                                def: def
                            });
                        }
                        return phrase; // Keep just the phrase
                    } else {
                        // No definition in parentheses
                        // Check if it's a phrase (multiple words) or single word
                        const isPhrase = /\s/.test(cleanContent);

                        if (isPhrase) {
                            // Multiple words ‚Üí phrase
                            extracted.push({word: cleanContent.trim(), fullMatch: match, type: 'phrase'});
                            return cleanContent.trim();
                        } else {
                            // Single word without POS ‚Üí DISCARD (don't extract)
                            return cleanContent.trim();
                        }
                    }
                });

                // 3. THEN: Extract *word* (Italics - unknown words)
                // Must be after word(def) patterns and **word** removal to avoid conflicts
                // Only extract if NOT already extracted in previous steps
                clean = clean.replace(/\*([a-zA-Z-]+)\*/g, (match, p1) => {
                    // Check if already extracted
                    const alreadyExtracted = extracted.some(e => e.word === p1.trim() && e.fullMatch === match);
                    if (!alreadyExtracted) {
                        // Check if this word was removed from *word([Èü≥Ê†á])* pattern (IPA only, no definition)
                        // These words should NOT be extracted as separate cards
                        const wordTrimmed = p1.trim();
                        const isIpaOnlyWord = ipaOnlyWords.includes(wordTrimmed);

                        if (!isIpaOnlyWord) {
                            // Check if this word already exists in extracted (from other patterns)
                            // If it does, don't extract again (avoid duplicate cards)
                            const wordExistsInExtracted = extracted.some(e => e.word === wordTrimmed);
                            if (!wordExistsInExtracted) {
                                extracted.push({word: wordTrimmed, fullMatch: match, type: 'word'});
                            }
                        }
                    }
                    return p1.trim(); // Keep just the word
                });

                // 4. Final cleanup: Remove any remaining asterisks (catch any missed patterns)
                clean = clean.replace(/\*/g, '');

                return {extracted, clean};
            }

            createCard(content, type) {
                // Support both /.../ and [...] formats for IPA
                const ipaMatchSlash = content.match(/\/.*?\//);
                const ipaMatchBracket = content.match(/\[[^\]]+\]/);
                let ipa = '';
                let wordText = content;
                if (ipaMatchSlash) {
                    ipa = ipaMatchSlash[0];
                    wordText = content.replace(ipaMatchSlash[0], '').trim();
                } else if (ipaMatchBracket) {
                    ipa = ipaMatchBracket[0];
                    wordText = content.replace(ipaMatchBracket[0], '').trim();
                }

                // Extract emoji from word text
                let emoji = '';
                const emojiMatch = wordText.match(/[\p{Emoji}\p{Emoji_Presentation}]/u);
                if (emojiMatch) {
                    emoji = emojiMatch[0];
                    wordText = wordText.replace(emojiMatch[0], '').trim();
                }

                let def = '';
                let cn = '';
                if (/^[a-zA-Z-]+\s+[a-z]+\./.test(wordText)) {
                    const parts = wordText.split(/(?=\s[a-z]+\.)/);
                    wordText = parts[0].trim();
                    // Use parts[1] directly (the part after the word), not join
                    const rest = parts.length > 1 ? parts[1].trim() : '';
                    // Try to split into POS (en) and Chinese (cn)
                    // Pattern: "n. ÔºàË∫´‰ΩìÊàñÊô∫Âäõ‰∏äÁöÑÔºâÊÆãÁñæ"
                    const posMatch = rest.match(/^([a-z]+\.)/);
                    if (posMatch) {
                        def = posMatch[1]; // Extract POS (n.)
                        cn = rest.substring(def.length).trim(); // Rest is Chinese
                    } else {
                        def = rest;
                    }
                }

                const card = {
                    id: `card_${this.cards.length}`,
                    word: wordText,
                    ipa: ipa,
                    type: type,
                    emoji: emoji,
                    items: def ? [{type: 'def', en: def, cn: cn}] : []
                };

                // For phrases without definitions, add a default item showing the phrase
                // BUT ONLY if we're not going to add a definition later
                // We'll only add this default item if the caller doesn't provide content
                // This check happens in the caller, not here
                return card;
            }
        }

        function runParser() {
            const input = document.getElementById('input').value;
            const output = document.getElementById('output');
            const stats = document.getElementById('stats');

            if (!input.trim()) {
                output.innerHTML = '<div class="error">ËØ∑ËæìÂÖ•ÊµãËØïÂÜÖÂÆπ</div>';
                stats.textContent = 'Á≠âÂæÖËæìÂÖ•...';
                return;
            }

            try {
                const parser = new MarkdownParser(input);
                const cards = parser.parse();

                // Update stats
                const wordCount = cards.filter(c => c.type === 'word').length;
                const phraseCount = cards.filter(c => c.type === 'phrase').length;
                const sentenceCount = cards.filter(c => c.type === 'sentence').length;
                stats.textContent = `ÂÖ± ${cards.length} Âº†Âç°Áâá (ÂçïËØç: ${wordCount}, ËØçÁªÑ: ${phraseCount}, ‰æãÂè•: ${sentenceCount})`;

                // Render cards
                output.innerHTML = cards.map((card, idx) => {
                    const typeClass = `type-${card.type}`;
                    const typeLabel = card.type === 'word' ? 'ÂçïËØç' : card.type === 'phrase' ? 'ËØçÁªÑ' : '‰æãÂè•';

                    let details = '';
                    if (card.ipa) {
                        details += ` | IPA: ${card.ipa}`;
                    }
                    if (card.items && card.items.length > 0) {
                        details += `\nÂÆö‰πâ: ${card.items.map(i => `${i.en}${i.cn ? ' ‚Üí ' + i.cn : ''}`).join('; ')}`;
                    }
                    if (card.synonyms && card.synonyms.length > 0) {
                        details += `\nÂêå‰πâËØç: ${card.synonyms.map(s => s.word).join(', ')}`;
                    }
                    if (card.antonyms && card.antonyms.length > 0) {
                        details += `\nÂèç‰πâËØç: ${card.antonyms.map(a => a.word).join(', ')}`;
                    }
                    if (card.fullText) {
                        details += `\nÂÆåÊï¥: ${card.fullText}`;
                    }

                    return `<div class="card-item">
                        <div>
                            <span class="card-type ${typeClass}">${typeLabel}</span>
                            <span class="card-word">#${idx + 1} ${card.word}</span>
                        </div>
                        <div class="card-detail">${details || '(Êó†ËØ¶ÊÉÖ)'}</div>
                    </div>`;
                }).join('\n');

            } catch (error) {
                output.innerHTML = `<div class="error">Ëß£ÊûêÈîôËØØ: ${error.message}\n\n${error.stack}</div>`;
                stats.textContent = 'Ëß£ÊûêÂ§±Ë¥•';
            }
        }

        // Set default example
        document.getElementById('input').value = `## acknowledge
- vt. ÊâøËÆ§ÔºõÂëäÁü•Êî∂ÊÇâÔºõÊÑüË∞¢
- === acknowledge([Àà…™pl…íd í…™z] (v. ÈÅìÊ≠â))
- I acknowledge your point.`;
    </script>
</body>
</html>
