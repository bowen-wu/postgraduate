<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Article Compare</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        textarea { width: 90%; height: 200px; margin-top: 10px; }
        label { font-weight: bold; display: block; margin-top: 10px; }
        .diff { margin-top: 10px; white-space: pre-wrap; font-family: monospace; line-height: 1.5; }
        .added { background: yellow; text-decoration: line-through; }
        .removed { background: #fbb6c2; font-weight: bold; }
        table { border-collapse: collapse; margin-top: 10px; width: 100%; }
        th, td { border: 1px solid #ccc; padding: 5px; text-align: left; vertical-align: top; }
        .legend span { display: inline-block; margin-right: 10px; padding: 2px 5px; }
        .red-text-green-bg { background: #d4fcbc; color: red; font-weight: bold; text-decoration: underline; }
    </style>
</head>
<body>
<h2>Compare Articles</h2>

<label for="seq">No.：</label>
<input type="text" id="seq">

<label for="textB">Your Article (with errors)：</label>
<textarea id="textB" placeholder="Paste your article (Article B) here..." spellcheck="false"></textarea>

<label for="files">Select Markdown file (contains correct articles)：</label>
<input type="file" id="files" accept=".md">

<br><br>
<button onclick="compare()">Compare</button>

<div class="legend">
    <strong>图例：</strong>
    <span class="added">黄色背景</span> = 多写单词，
    <span class="removed">红色背景</span> = 漏写单词，
    <span class="red-text-green-bg">(红字绿底)</span> = 拼写错误
</div>

<div id="result" class="diff"></div>
<div id="errorTable"></div>

<script src="https://unpkg.com/diff@5.2.0/dist/diff.min.js"></script>
<script src="https://unpkg.com/typo-js@1.2.2/typo.js"></script>

<script>
  let dictionary;

  // 初始化拼写字典
  async function initDictionary() {
    try {
      const aff = await fetch('en_US.aff').then(r => r.text());
      const dic = await fetch('en_US.dic').then(r => r.text());
      dictionary = new Typo('en_US', aff, dic, {platform: 'any'});
      console.log('Dictionary loaded');
    } catch (e) {
      console.warn('Dictionary not loaded, spelling check disabled');
    }
  }

  // 缩写表
  const contractions = {
    'I\'m': 'I am',
    'you\'re': 'you are',
    'he\'s': 'he is',
    'she\'s': 'she is',
    'it\'s': 'it is',
    'we\'re': 'we are',
    'they\'re': 'they are',
    'I\'ve': 'I have',
    'you\'ve': 'you have',
    'we\'ve': 'we have',
    'they\'ve': 'they have',
    'I\'ll': 'I will',
    'you\'ll': 'you will',
    'he\'ll': 'he will',
    'she\'ll': 'she will',
    'it\'ll': 'it will',
    'we\'ll': 'we will',
    'they\'ll': 'they will',
    'don\'t': 'do not',
    'doesn\'t': 'does not',
    'didn\'t': 'did not',
    'can\'t': 'cannot',
    'couldn\'t': 'could not',
    'won\'t': 'will not',
    'wouldn\'t': 'would not',
    'isn\'t': 'is not',
    'aren\'t': 'are not',
    'wasn\'t': 'was not',
    'weren\'t': 'were not',
    'let\'s': 'let us',
    'that\'s': 'that is',
    'there\'s': 'there is',
    'here\'s': 'here is',
    'what\'s': 'what is',
    'who\'s': 'who is'
  };

  function expandContractions(text) {
    for (const [abbr, full] of Object.entries(contractions)) {
      const re = new RegExp(`\\b${abbr}\\b`, 'g');
      text = text.replace(re, full);
    }
    return text;
  }

  function checkSpelling(word) {
    if (!dictionary) return true;
    const cleanWord = word.replace(/[^a-zA-Z']/g, '');
    return cleanWord ? dictionary.check(cleanWord) : true;
  }

  function markdownToText(md) {
    return md
      .replace(/<br\s*\/?>/gi, '\n')
      .replace(/<[^>]+>/g, '')
      .replace(/\*\*(.*?)\*\*/g, '$1')
      .replace(/&emsp;/g, ' ')
      .replace(/&nbsp;/g, ' ')
      .replace(/\r\n/g, '\n')
      .trim();
  }

  async function compare() {
    const seq = document.getElementById('seq').value.trim();
    const file = document.getElementById('files').files[0];
    const textB = document.getElementById('textB').value;
    const resultEl = document.getElementById('result');
    const tableEl = document.getElementById('errorTable');
    resultEl.innerHTML = '';
    tableEl.innerHTML = '';

    if (!seq) {
      alert('请输入编号');
      return;
    }
    if (!file) {
      alert('请选择一个 Markdown 文件');
      return;
    }
    if (!textB) {
      alert('请输入需要对比的文章（Article B）');
      return;
    }

    const content = await file.text();
    const regex = new RegExp(`##\\s*${seq}([\\s\\S]*?)(?=\\n##|$)`, 'i');
    const match = content.match(regex);
    if (!match) {
      alert(`未找到编号 ${seq} 对应的文章`);
      return;
    }

    let textA = markdownToText(match[1]);
    const textA_exp = expandContractions(textA);
    const textB_exp = expandContractions(textB);

    const diff = Diff.diffWords(textA_exp, textB_exp);
    let resultHTML = '';
    let errors = [];

    for (let i = 0; i < diff.length; i++) {
      const part = diff[i];

      // 仅当 removed + added 各自 1 个单词时才视为拼写替换
      if (part.removed && i + 1 < diff.length && diff[i + 1].added) {
        const removedWords = part.value.split(/\s+/).filter(Boolean);
        const addedWords = diff[i + 1].value.split(/\s+/).filter(Boolean);

        if (removedWords.length === 1 && addedWords.length === 1) {
          const correct = removedWords[0];
          const wrong = addedWords[0];
          resultHTML += `<span style="color:green;">${correct}</span> `;
          resultHTML += `<span class="red-text-green-bg">(${wrong})</span> `;
          errors.push({word: wrong, correct: correct, type: '拼写错误'});
          i++; // 跳过下一个 added
          continue;
        }
      }

      if (part.added) {
        const words = part.value.split(/\s+/).filter(Boolean);
        words.forEach((w) => {
          // 简化逻辑：直接标记为多写单词
          resultHTML += `<span class="added">${w}</span> `;
          errors.push({word: w, type: '多写'});
        });
      } else if (part.removed) {
        const words = part.value.split(/\s+/).filter(Boolean);
        words.forEach(w => {
          resultHTML += `<span class="removed">${w}</span> `;
          errors.push({word: w, type: '漏写'});
        });
      } else {
        resultHTML += part.value;
      }
    }

    resultEl.innerHTML = resultHTML;
  }

  initDictionary();
</script>
</body>
</html>
